<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Haohao&#39;s Blog</title>
  
  <subtitle>To be a better man.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.simbleman.com/"/>
  <updated>2019-08-16T13:46:47.437Z</updated>
  <id>http://www.simbleman.com/</id>
  
  <author>
    <name>Haoocker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Blog_09_使用Flutter的第一个页面</title>
    <link href="http://www.simbleman.com/2019/08/16/Blog-09-%E4%BD%BF%E7%94%A8Flutter%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2/"/>
    <id>http://www.simbleman.com/2019/08/16/Blog-09-使用Flutter的第一个页面/</id>
    <published>2019-08-16T13:08:22.000Z</published>
    <updated>2019-08-16T13:46:47.437Z</updated>
    
    <content type="html"><![CDATA[<p>终于开始将flutter的布局开始了解和学习了，经过这一天和它的接触，发现它真的比Android要好用一点，没有像Android那么多复杂的配置和不知道怎么写Java代码的困扰。flutter中的dart还是挺容易去了解和学习的。</p><h4 id="初次开发"><a href="#初次开发" class="headerlink" title="初次开发"></a>初次开发</h4><div align="center"><br>  <img width="300" src="/images/flutter.jpg"><br></div><p>Flutter的开发相对android开发目前印象良好，因为它简便地多，可以不再用那个很难搞懂的android studio开发了，不过唯一使用下来感觉是前端界面如果比较复杂，真的代码就看不懂了，因为flutter的界面设计并没有像android那样可以在android studio中进行可视化设计，所以界面都是靠代码堆叠起来的，因此一旦界面复杂，那么代码的可读性真的很糟糕。<br>今天并不打算介绍我的全部代码，因为它的可读性问题，可能我在后面有时间的时候会再来修改一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;终于开始将flutter的布局开始了解和学习了，经过这一天和它的接触，发现它真的比Android要好用一点，没有像Android那么多复杂的配置和不知道怎么写Java代码的困扰。flutter中的dart还是挺容易去了解和学习的。&lt;/p&gt;
&lt;h4 id=&quot;初次开发&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="flutter" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/flutter/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_08_dart重写小程序</title>
    <link href="http://www.simbleman.com/2019/08/15/Blog-08-dart%E9%87%8D%E5%86%99%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.simbleman.com/2019/08/15/Blog-08-dart重写小程序/</id>
    <published>2019-08-15T14:55:32.000Z</published>
    <updated>2019-08-15T14:57:17.392Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天的文章是关于我用dart语言重写我之前的一个代码的例子，以后我也会尽量从这样的例子中来说明一个语法或者一个问题！<br>&emsp;&emsp;不得不说dart与C++比起来好像并没有那么复杂，语法比较简单明了！</p><p>####简单例子1<br>首先来看在C++中的源代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int i,j;</span><br><span class="line">        for(i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">        for(j=i+1;j&lt;nums.size();j++)&#123;</span><br><span class="line">        if(nums[i]+nums[j]==target)&#123;</span><br><span class="line">        return &#123;i,j&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>下面是我用dart重写之后的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line"> List&lt;int&gt; twoSum(List&lt;int&gt; nums,int target)&#123;</span><br><span class="line">   //在dart中返回类型也可以不写，且方法没有加_一律都是公有方法</span><br><span class="line">    for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">      for(int j=i+1;j&lt;nums.length;j++)&#123;</span><br><span class="line">        if(nums[i]+nums[j]==target)</span><br><span class="line">          return [i,j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [];//返回一个空的List</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####简单例子2<br>这同样是C++的代码，是上面代码的改进版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        map&lt;int,int&gt; a;//建立hash表存放数组元素</span><br><span class="line">        vector&lt;int&gt; b(2,-1);//存放结果</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">            a.insert(map&lt;int,int&gt;::value_type(nums[i],i));</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a.count(target-nums[i])&gt;0&amp;&amp;(a[target-nums[i]]!=i))</span><br><span class="line">            //a.count(键值)返回0或1，代表是否存在键值</span><br><span class="line">            &#123;</span><br><span class="line">                b[0]=i;</span><br><span class="line">                b[1]=a[target-nums[i]];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>同样，可以用dart来改写一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution2&#123;</span><br><span class="line">  twoSum(List&lt;int&gt; nums,int target)&#123;</span><br><span class="line">    Map a=new Map();</span><br><span class="line">    //这里不可以用在C++中定义Map的方法：Map&lt;int&gt;&lt;int&gt; map;</span><br><span class="line">    //因为在dart中一切都是对象，所以这样的定义方法会简单很多</span><br><span class="line">    //甚至可以不加new关键词 Map a=Map();</span><br><span class="line">    List list=new List&lt;int&gt;();</span><br><span class="line">    for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">      a.addAll(&#123;nums[i]:i&#125;);</span><br><span class="line">      //向Map中添加数据，一般用addAll函数，注意写法</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">      if(a.containsKey(target-nums[i])&amp;&amp;a[target-nums[i]]!=i)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">        list.add(a[target-nums[i]]);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>不得不说，在Dart中没有C++中那么复杂的Map定义和使用，不过也只有当很熟练掌握之后dart之后才能发挥更大的功效。</p><p>####关于flutter<br>这两天我在自己的电脑上完成了flutter环境的搭建以及分别在vscode中和android studio中搭建了flutter的环境。flutter的正式介绍应该是从明天开始！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;今天的文章是关于我用dart语言重写我之前的一个代码的例子，以后我也会尽量从这样的例子中来说明一个语法或者一个问题！&lt;br&gt;&amp;emsp;&amp;emsp;不得不说dart与C++比起来好像并没有那么复杂，语法比较简单明了！&lt;/p&gt;
&lt;p&gt;####简单例子1
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="flutter" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/flutter/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_07_关于内容的杂谈</title>
    <link href="http://www.simbleman.com/2019/08/14/Blog-07-%E5%85%B3%E4%BA%8E%E5%86%85%E5%AE%B9%E7%9A%84%E6%9D%82%E8%B0%88/"/>
    <id>http://www.simbleman.com/2019/08/14/Blog-07-关于内容的杂谈/</id>
    <published>2019-08-14T15:09:25.000Z</published>
    <updated>2019-08-14T15:10:56.427Z</updated>
    
    <content type="html"><![CDATA[<p>其实了解下来感觉dart就是各种语言的大杂烩，你可以看见java的影子，你也可以看见JavaScript的影子，你甚至可以看见swift的影子，难怪说flutter是跨平台的呢，从这个语言的特征就能看出来了。</p><p>###我想说的<br>因为最近的Blog大部分都是这种知识类型的介绍，这是我学习成果的展示，也是我学习的过程。但由于在学习的过程中，我已经完成了大部分代码的编写，所以当我在写Blog的时候，设计代码的部分我会选择直接将我写好的代码拿过来复制粘贴，虽然能节省我写Blog的很多时间，可是这完全就是一种无意义的行为，因此从今天开始，我只会将我总结性的内容呈现出来，而不再是过程性的知识。</p><p>###所以今天不再是dart相关的基础内容<br>我思考了一下，决定今天的内容不再和dart相关，这个内容可能需要我接下来思考一下以什么样的方式呈现出来，所以今天纯粹是一种杂谈，本来打算是关于dart的剩下内容关于函数和类，我却发现其实这样的方式是有一定的问题的，因此今天暂停这样的内容呈现方式！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实了解下来感觉dart就是各种语言的大杂烩，你可以看见java的影子，你也可以看见JavaScript的影子，你甚至可以看见swift的影子，难怪说flutter是跨平台的呢，从这个语言的特征就能看出来了。&lt;/p&gt;
&lt;p&gt;###我想说的&lt;br&gt;因为最近的Blog大部分都是
      
    
    </summary>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
      <category term="杂谈" scheme="http://www.simbleman.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Blog_06_Dart基础</title>
    <link href="http://www.simbleman.com/2019/08/13/Blog-06-Dart%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.simbleman.com/2019/08/13/Blog-06-Dart基础/</id>
    <published>2019-08-13T13:39:02.000Z</published>
    <updated>2019-08-13T13:40:09.374Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要是了解了dart相关的一些最基本的知识，并尝试在vscode和android studio中搭建了flutter环境，在vs code中进行flutter环境的搭配是要用到第三方的插件，但由于flutter还并没有像android那样火爆，因此并没有一个专门为他设计的ide，在android studio中也可以搭建flutter环境，也是像在vs code中需要借助第三方插件来进行开发。</p><h3 id="dart语言基础"><a href="#dart语言基础" class="headerlink" title="dart语言基础"></a>dart语言基础</h3><p>在<a href="https://dart.dev" target="_blank" rel="noopener">dart官网</a>,可以获得到所有关于dart环境安装的必需下载。也会有关于安装步骤的说明，当然你也可以去网上搜索教程来学习。</p><p>####dart一些常见和特殊的语法用法</p><ol><li>main函数<br>dart中函数的定义一般都是(){}的形式，main函数也不例外。一种定义的方法:main(){}还有一种定义的方法是:void main(){}</li><li><p>字符串的拼接<br>字符串的拼接可以像c语言或者java中用”+”完成，还有一种方式是使用$特殊符号完成（类似于引用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string1=&quot;Hello,&quot;;</span><br><span class="line">var string2=&quot;world!&quot;;</span><br><span class="line">print(string1+string2);</span><br><span class="line">print(&quot;$string1 $string2&quot;);//加双引号</span><br></pre></td></tr></table></figure></li><li><p>函数<br>dart中函数的定义和C++，java中的大同小异。不过还是有特殊的定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义一个可选参数的函数：</span><br><span class="line">String printUserInfo(String username,[int age,String sex=&apos;男&apos;])&#123;//可选参数用中括号，默认参数可以在可选参数中设置</span><br><span class="line">if(age!=null)</span><br><span class="line">  return &quot;姓名: $username===年龄:$age&quot;;</span><br><span class="line">else</span><br><span class="line">  return &quot;姓名: $username===年龄:保密&quot;;</span><br><span class="line">&#125;</span><br><span class="line">print(printUserInfo(&quot;张三&quot;));</span><br><span class="line">//在这里函数的调用过程中，省去了age和sex，因为这是在函数的形参中被定义成了可选参数，sex还是一个默认参数。</span><br></pre></td></tr></table></figure></li></ol><p>4.变量<br>因为dart的强语言特性，所以dart可以不预先定义变量类型，用var,例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;您好dart&quot;;</span><br><span class="line">var num=123;</span><br><span class="line">//也可以通过明示来定义变量</span><br><span class="line">String str=&quot;hello world&quot;;</span><br><span class="line">print(str);</span><br><span class="line">//变量的名称是区分大小写的</span><br></pre></td></tr></table></figure></p><p>####dart中关于List和map相关</p><ol><li><p>定义<br>list和map都有两种定义的方法，一种是直接定义法，如List：<code>var list=[123,12334,321321];</code>第二种是<code>var list=new List();list.add(123);</code><br>map：<code>第一种定义的方式：<br>var person={<br> “name”:”张三”,<br> “phone”:1234 ,<br> “work”:{<br>   “work1”:”常州”,<br>   “work2”:”南京”<br> }<br>};<br>第二种定义的方式：<br>var p=new Map();<br>p[“name”]=”李四”;<br>p[“age”]=22;</code></p><ol start="2"><li>增加和删除数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">增加数据：</span><br><span class="line">list:</span><br><span class="line">  list.add(&quot;桃子&quot;);//增加一个数据</span><br><span class="line">  list.addAll([&quot;栗子&quot;,&quot;杏子&quot;]);//传入的是一个数组,相当于是拼接数组</span><br><span class="line"></span><br><span class="line">  map:只有一种增加数据的方法</span><br><span class="line">  person.addAll(&#123;</span><br><span class="line">  &quot;work&quot;:[&apos;码农&apos;,&apos;教师&apos;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  删除数据：</span><br><span class="line">  list:</span><br><span class="line">list.remove(&apos;苹果&apos;); //根据名称删除</span><br><span class="line">print(list);</span><br><span class="line">list.removeAt(1);//根据下标删除</span><br><span class="line">print(list);</span><br></pre></td></tr></table></figure></li><li><p>遍历list和map的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1:用for循环:类似于C++和java中那样的循环</span><br><span class="line">2:用item</span><br><span class="line">for( var item in list)&#123;</span><br><span class="line">   print( item);</span><br><span class="line">&#125;</span><br><span class="line">3：用foreach</span><br><span class="line">list.forEach((value)&#123;</span><br><span class="line">  print(&quot;$value&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>set相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set用它最主要的功能就是去除数组重复的内容</span><br><span class="line">var newset=new Set();</span><br><span class="line">newset.add(&apos;苹果&apos;);</span><br><span class="line">newset.add(&apos;香蕉&apos;);</span><br><span class="line">newset.add(&apos;苹果&apos;);</span><br><span class="line">print(newset);</span><br><span class="line">只会打印出两个数值，因为有&quot;苹果&quot;重复了</span><br><span class="line">print(newset.toList());</span><br><span class="line">将set可以轻易转换成list</span><br></pre></td></tr></table></figure></li></ol><p>####dart语言特性</p><ol><li>强类型语言，变量的类型指定不一定要标明，因为Dart可以推断出它的类型。</li><li>在dart语言中，所有对象的类都是一个类的实例，甚至是整数，函数，null也看作对象<br>暂且所了解的比较深刻的就是这两点，所以暂且先列出这两点</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天主要是了解了dart相关的一些最基本的知识，并尝试在vscode和android studio中搭建了flutter环境，在vs code中进行flutter环境的搭配是要用到第三方的插件，但由于flutter还并没有像android那样火爆，因此并没有一个专门为他设计
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="flutter" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/flutter/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_05:关于flutter框架的了解</title>
    <link href="http://www.simbleman.com/2019/08/12/Blog-05-%E5%85%B3%E4%BA%8Eflutter%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
    <id>http://www.simbleman.com/2019/08/12/Blog-05-关于flutter框架的了解/</id>
    <published>2019-08-12T14:54:46.000Z</published>
    <updated>2019-08-13T13:40:07.376Z</updated>
    
    <content type="html"><![CDATA[<p>经过大概半天的思考，最终决定还是先从dart开始了解，再去了解futter这个谷歌的新型跨平台框架。这样看起来android都已经要过时了呢。</p><h3 id="flutter：一个跨平台的框架"><a href="#flutter：一个跨平台的框架" class="headerlink" title="flutter：一个跨平台的框架"></a>flutter：一个跨平台的框架</h3><p>相信很多人都有听说过flutter，几乎从去年的谷歌io大会之后flutter就很火。各种说法蜂拥而至，这让flutter受到了前所未有的关注。据官网介绍，国内的闲鱼平台二手商品的的详细界面就是使用flutter写成的，一套代码，就完成了在android和ios系统上运行的要求。因为他优秀的跨平台性和他流畅的运行结果，而且学习和使用这个框架也不是很难，所以我也被吸引到了解和学习他的过程中。</p><h3 id="dart语言"><a href="#dart语言" class="headerlink" title="dart语言"></a>dart语言</h3><p>flutter使用dart语言，所以了解flutter，先学会dart是很有必要的。dart的很多语法和java很像，因为今天时间的原因，没有将dart详细了解，只是粗略的看了一下，同时今天也将dart的运行环境搭建完成，因为国内网络的原因，所以在一开始的下载过程中遇到了很大的影响，但是一旦下载好sdk，就能容易进行环境的搭建啦，今天就先这样草草结束，从明天开始将正式讲解dart的语法和使用！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过大概半天的思考，最终决定还是先从dart开始了解，再去了解futter这个谷歌的新型跨平台框架。这样看起来android都已经要过时了呢。&lt;/p&gt;
&lt;h3 id=&quot;flutter：一个跨平台的框架&quot;&gt;&lt;a href=&quot;#flutter：一个跨平台的框架&quot; class=&quot;
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="flutter" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/flutter/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_04:杂谈</title>
    <link href="http://www.simbleman.com/2019/08/11/Blog-04-%E6%9D%82%E8%B0%88/"/>
    <id>http://www.simbleman.com/2019/08/11/Blog-04-杂谈/</id>
    <published>2019-08-11T14:21:54.000Z</published>
    <updated>2019-08-11T14:23:46.262Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天是周日，因此就和自己的朋友出去聚了聚餐，聊了很多，关于很多。所以今天的学习内容没有，主要是自己的一些观点和感悟。</p><h3 id="关于程序员和编程"><a href="#关于程序员和编程" class="headerlink" title="关于程序员和编程"></a>关于程序员和编程</h3><p>&emsp;&emsp;编程的这条道路对每个程序员来说是必不可少的，也是非常艰辛的，之前的一段时间一直有新闻爆料一个又一个程序员倒在了自己的工作岗位上，同时也在爆料一个又一个大型互联网公司实行996工作制度，这引起了很多程序员的不满，也引起了社会的广泛关注。<br>&emsp;&emsp;在我看来，程序员的这个职位就是个搬砖的，纯粹是在用自己的纯劳动力换取工资，因此这不是什么大家以为的很高科技很炫酷的岗位，也不是大家看见电影里面的那种坐在电脑前面敲几行代码就能攻破美国国家国防部的防御墙。在这个岗位上你是敲着自己的代码，并且要为一个公司的利润和业绩带来提升的，如果你真的可以几行代码就能搞定一切，那么你也不会去公司找工作，你也不会来做程序员。因此程序员就是很普通的一类人，不错是用自己的脑力和体力换取工资和金钱的。<br>&emsp;&emsp;想要成为一名程序员，门槛也不是很高，所以为什么大家都会跳槽来这个岗位，除了高工资高待遇，可能也有这一部分原因。程序员的主要工作当然是编程，因此编程很重要，从我大一接触计算机以来，也不过只学了C++,java等语言，因此我们掌握的东西还很有限，能运用的场景也不是很多，所以是要不断加强语言的掌握程度的。因此接下来的一段时间里，我可能集中叙述一些java相关和一些其他语言的。我觉得可能我会尽可能增加自己的实际例子来穿插。<br>&emsp;&emsp;嗯..今天的杂谈到这里就先匆匆结束了。晚安，我们明天再见</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;今天是周日，因此就和自己的朋友出去聚了聚餐，聊了很多，关于很多。所以今天的学习内容没有，主要是自己的一些观点和感悟。&lt;/p&gt;
&lt;h3 id=&quot;关于程序员和编程&quot;&gt;&lt;a href=&quot;#关于程序员和编程&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
      <category term="杂谈" scheme="http://www.simbleman.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Blog_03:补充git的剩余部分</title>
    <link href="http://www.simbleman.com/2019/08/10/Blog-03-%E8%A1%A5%E5%85%85git%E7%9A%84%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86/"/>
    <id>http://www.simbleman.com/2019/08/10/Blog-03-补充git的剩余部分/</id>
    <published>2019-08-10T13:48:10.000Z</published>
    <updated>2019-08-10T13:48:59.934Z</updated>
    
    <content type="html"><![CDATA[<p>今天是台风登陆大陆的一天，也是一个周末，所以今天的内容不会太多，就是补充昨天git的剩余关于分支(branch)的部分。</p><h3 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h3><p>在这里需要了解一下git是如何保存数据的：git保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。在进行提交操作的时候，，Git会保存一个提交对象。git的分支，本质上就是指向提交对象的可变指针。</p><h4 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h4><pre><code>git branch testing 只会创建一个testing分支。</code></pre><p>注意：git的默认分支名字是master，当使用git init命令的时候自动创建，同时git有一个名为HEAD的特殊指针，他是一个指向当前所在的本地分支，默认是master，所以要切换指针的的话要用到下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout testing切换到分支testing，这样HEAD会指向testing</span><br><span class="line">git checkout -b testing 会创建一个分支testing并自动切换到分支上去</span><br><span class="line">git log --oneline --decorate --graph --all 它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</span><br></pre></td></tr></table></figure><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>如果当你已经完成了testing分支的工作，想要把testing分支合并到主分支中去（也就是master）可以运行git merge<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master切换到master分支</span><br><span class="line">git merge testing 将testing分支合并到master</span><br></pre></td></tr></table></figure></p><p>注意：如果在两个分支中对同一个文件的同一个部分进行了不同的修改，则会产生冲突，这时候当你merge的时，git会暂停下来等待你去解决合并产生的冲突。</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><pre><code>git branch -v可以查看每个分支的最后一次提交git branch -d可以删除掉当前分支（需要注意这是你已经合并之后的不需要的分支）</code></pre><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><pre><code>git ls-remote (remote) 来 显式地获得远程引用的完整列表</code></pre><p>首先你需要知道当你clone一个仓库之后，你的本地会产生一个master分支，而服务器上的master分支在本地会变成origin/master，但你看见这个就代表是服务器上的master了。 git fetch origin会拉取服务器上的master的所有数据，更新本地的数据库。当你git fetch之后本地的master分支依旧是没有变化的，还需要加上git merge来手动合并服务器上的数据。但是当你使用了git pull便可以拉取数据并自动合并到当前所指的分支。这也是昨天所说的：git pull=git fetch+git merge.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是台风登陆大陆的一天，也是一个周末，所以今天的内容不会太多，就是补充昨天git的剩余关于分支(branch)的部分。&lt;/p&gt;
&lt;h3 id=&quot;git分支&quot;&gt;&lt;a href=&quot;#git分支&quot; class=&quot;headerlink&quot; title=&quot;git分支&quot;&gt;&lt;/a&gt;git
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_02:关于git和github</title>
    <link href="http://www.simbleman.com/2019/08/09/Blog-02-%E5%85%B3%E4%BA%8Egit%E5%92%8Cgithub/"/>
    <id>http://www.simbleman.com/2019/08/09/Blog-02-关于git和github/</id>
    <published>2019-08-09T14:33:47.000Z</published>
    <updated>2019-08-09T14:38:23.120Z</updated>
    
    <content type="html"><![CDATA[<p><code>工欲善其事必先利其器</code><br>github被戏称为是世界上最大的同性社交平台，这肯定是有它自己独特的魅力。我也很早就被他的这种魅力所吸引，但是终究只是沉醉于它那富丽堂皇的表面，而迟迟没有去欣赏它真实的内涵。</p><h3 id="git和github"><a href="#git和github" class="headerlink" title="git和github"></a>git和github</h3><p>&emsp;&emsp;<a href="https://github.com/" target="_blank" rel="noopener">github</a>简单来说是一个代码托管平台，你可以将自己的项目代码放到这个平台中去，这是一个公开的平台，所有人将可以看见你的项目的代码，除非你买了私人的github账号和仓库。在我的理解中这就是程序员们交流的一个平台，全世界所有的程序员在这个平台中是平等的，说全世界是因为这大概是为数不多的没有被中国所墙掉的网站，你可以在这个平台上可以展示自己的项目的代码，也可以免费看到那些优秀程序员的项目的源代码，还可以在项目中提出issue和作者交流。<br>&emsp;&emsp;而git算是github网站的核心技术，git是什么，在廖雪峰的官方网站上他写到：“Git是目前世界上最先进的分布式版本控制系统（没有之一）。” 可以说这是对git很高很高的评价了。一开始了解git可能我们都并不是很了解为什么要这么说，但当你了解到一定程度之后你会发现，“嗯…好像真的有点厉害”。好了废话这么多就正式进入正题！</p><h3 id="git工作的三个区域"><a href="#git工作的三个区域" class="headerlink" title="git工作的三个区域"></a>git工作的三个区域</h3><p>学习git首先要了解的就是git做为版本控制系统的三个最基本的区域。这也是git很多命令理解的前提和关键</p><ol><li>git仓库<br>我个人的理解就是最终代码和文件的存放的区域，一般是你把所有暂时不需要修改的代码和文件放在这个区域。相当于一个产品暂时最终的样子，说是暂时的因为你还可以再次修改，修改完成之后还可以覆盖掉原来的产品。</li><li>工作目录<br>可以理解成你完成代码的编写和文件的修改等等的区域，相当于一个产品的车间，你在这里完成一切产品的加工和创造</li><li>暂存区域<br>顾名思义。这里的文件和代码是在工作目录完成之后暂存的，准备提交到git仓库的区域。相当于一个产品的中转站，在车间完成之后从这里转存到最终的目的地。</li></ol><h3 id="git的常用命令"><a href="#git的常用命令" class="headerlink" title="git的常用命令"></a>git的常用命令</h3><p>我们一般用git bash来完成git的所有工作。因此命令的掌握是非常重要的。</p><ol><li>git clone https://… projectname可以从github中克隆一个仓库</li><li>git status 查看git的三个区域中的文件的状态。</li><li>git status -s 简化版本：例：<br>M README<br>MM Rakefile<br>A lib/git.rb<br>M lib/simplegit.rb<br>?? LICENSE.txt<br>新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左<br>边的 M 表示该文件被修改了并放入了暂存区。Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</li><li>git add相当于文件已经被跟踪并储存到暂存区</li><li>git diff 用来查看尚未暂存的文件更新了哪些部分<br>git diff –cached或者git diff –staged查看已经暂存起来的变化</li><li>git commit将暂存区域中的文件提交到git仓库中<br>可以使用git commit -m ‘将本次的提交信息可以写在这里’<br>git commit -a可以跳过git add（已跟踪文件）</li><li>git rm   连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清 单中了。<br>git rm -f强制删除文件，针对还没有commit的文件</li><li>git mv filename1 filename2可以给文件改名字</li><li>git log 有很多的参数选择</li><li>撤销：有时候提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行<br>$ git commit –amend<br>“git reset HEAD filename撤销将一个文件放入暂存区（移出暂存区）<br>git checkout – filename撤消对文件的修改</li><li>git remote，如果是克隆的会显示origin<br>git remote -v 会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</li></ol><h3 id="关于分支branch"><a href="#关于分支branch" class="headerlink" title="关于分支branch"></a>关于分支branch</h3><p>&emsp;&emsp;首先要区别git fetch 和git pull的区别，这两个的区别显得很重要，要必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。而运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支，一般当前的分支就是master。简单理解：git pull=git fetch+git merge.<br>&emsp;&emsp;关于分支的设计可以说是git显得很强大的一个重要原因，因为篇幅和时间的原因，我准备下次再来好好谈谈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;工欲善其事必先利其器&lt;/code&gt;&lt;br&gt;github被戏称为是世界上最大的同性社交平台，这肯定是有它自己独特的魅力。我也很早就被他的这种魅力所吸引，但是终究只是沉醉于它那富丽堂皇的表面，而迟迟没有去欣赏它真实的内涵。&lt;/p&gt;
&lt;h3 id=&quot;git和githu
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_01:关于Markdown语法</title>
    <link href="http://www.simbleman.com/2019/08/08/Blog-01-%E5%85%B3%E4%BA%8EMarkdown%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.simbleman.com/2019/08/08/Blog-01-关于Markdown语法/</id>
    <published>2019-08-08T12:00:00.000Z</published>
    <updated>2019-08-08T12:07:54.326Z</updated>
    
    <content type="html"><![CDATA[<pre><code>工欲善其事必先利其器</code></pre><h3 id="1-使用Markdown语法的原因"><a href="#1-使用Markdown语法的原因" class="headerlink" title="1.使用Markdown语法的原因"></a>1.使用Markdown语法的原因</h3><p>&emsp;&emsp;从我开始写blog的第一天就学习了这个Markdown的语法，要说使用它的原因，我现在还真的说不出到底为什么，不过用markdown语法写一段时间文章，相信我你会喜欢上它的。在Markdown设计之初就是致力于是阅读和创作文档变得更容易，在使用的过程中的确有一种效率更高的感觉，因为你再也不需要用鼠标和按钮进行排版了。</p><hr><h3 id="2-Markdown语法"><a href="#2-Markdown语法" class="headerlink" title="2.Markdown语法"></a>2.Markdown语法</h3><p>&emsp;&emsp;最基本的用法在这里我就不具体介绍了，当你在搜索引擎搜索之后会发现教程实在是很多。甚至有教程在宣扬5分钟之内就可以学会，的确学习之后发现Markdown相比于html语法还是比较简单的。但是今天当我重新了解了一遍Markdown之后，我发现有几个语法一直没有注意到,所以就着重记录几个。</p><h4 id="是关于有序列表数字的问题"><a href="#是关于有序列表数字的问题" class="headerlink" title="是关于有序列表数字的问题"></a>是关于有序列表数字的问题</h4><p>&emsp;&emsp;有序列表是通过数字加半角的句号完成的，如”1.”表示第一个。<br>但是在使用的过程中发现数字是可以无序的，也就是说当你1.以后后一行应该用2.但是你用了3.或者任何一个数字显示出来依旧是2.<br>可以看一下接下来的两个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 这是第一行      </span><br><span class="line">6. 这是第二行                     </span><br><span class="line">7. 这是第三行</span><br></pre></td></tr></table></figure></p><p>显示出来：</p><ol><li>这是第一行      </li><li>这是第二行                     </li><li>这是第三行</li></ol><p>所以下次只要注意列表的第一个数字就足够了</p><h4 id="关于转义字符的问题"><a href="#关于转义字符的问题" class="headerlink" title="关于转义字符的问题"></a>关于转义字符的问题</h4><p>&emsp;&emsp;首先说明在Markdown中转义字符是“\”（反斜杠）它可以完成特殊字符的一般化比如\<em>这里的字体没有受到\</em>的影响\*，如果去掉两个转义字符就变成了：<em>这里的字体没有受到\</em>的影响*，显然已经受到了影响（变成粗体了）。</p><h4 id="关于内联元素的链接问题"><a href="#关于内联元素的链接问题" class="headerlink" title="关于内联元素的链接问题"></a>关于内联元素的链接问题</h4><p>&emsp;&emsp;首先看这一段话：“你可以在<a href="https://www.baidu.com/" title="点击百度一下！" target="_blank" rel="noopener">百度</a>上进行搜索，也可以在<a href="https://www.google.com/" title="点击进行谷歌搜索" target="_blank" rel="noopener">谷歌</a>上进行搜索我的blog”<br>以下是上面那句话的源代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“你可以在[百度][]上进行搜索，也可以在[谷歌][]上进行搜索我的blog”</span><br><span class="line"></span><br><span class="line">[百度]: https://www.baidu.com/   &quot;点击百度一下！&quot;</span><br><span class="line">[谷歌]: https://www.google.com/  &quot;点击进行谷歌搜索&quot;</span><br></pre></td></tr></table></figure></p><p>还有第二种实现方法贴上源代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“你可以在[百度][1]上进行搜索，也可以在[谷歌][2]上进行搜索我的blog”</span><br><span class="line"></span><br><span class="line">[1]: https://www.baidu.com/   &quot;点击百度一下！&quot;</span><br><span class="line">[2]: https://www.google.com/  &quot;点击进行谷歌搜索&quot;</span><br></pre></td></tr></table></figure></p><p>以上的效果是一样的但是原理不同，第二种个人感觉有点类似html中的id属性的实现方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;工欲善其事必先利其器
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;1-使用Markdown语法的原因&quot;&gt;&lt;a href=&quot;#1-使用Markdown语法的原因&quot; class=&quot;headerlink&quot; title=&quot;1.使用Markdown语法的原因&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>主题更换以及一些说明</title>
    <link href="http://www.simbleman.com/2019/08/07/%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/"/>
    <id>http://www.simbleman.com/2019/08/07/主题更换以及一些说明/</id>
    <published>2019-08-07T11:42:55.000Z</published>
    <updated>2019-08-09T14:36:37.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：主题更换"><a href="#一：主题更换" class="headerlink" title="一：主题更换"></a>一：主题更换</h2><h3 id="1：前情概要"><a href="#1：前情概要" class="headerlink" title="1：前情概要"></a>1：前情概要</h3><p>  &emsp;&emsp;距离我上一次更新已经过去很久了，从上一次更新到现在发生了很多事情，曾一度想关闭这个博客想重新开一个自己的网站，但是想到目前自己真的没有很大的需求去开一个网站，想开网站无非是折腾自己，有点大材小用的意思，所以我还是回到了这个blog。 <br><br>  &emsp;&emsp;4月份和5月份大概是我自己瞎忙的时候，我也不知道自己在忙什么，所以从那个时候开始就想着有时间来整一整，然后才发现真的不要相信自己对自己说的谎话，以后可能是无限期。就这样从六月份开始我应该在忙着准备期末考试了，（嗯..期末就不想提了，太心痛！）那一备考阶段感觉是我上半年最迷茫的时候…所以就这样到7月中旬期末考试结束后我就回家了。接着就是半个月去福建福州和厦门的旅行，可以说是一次身心的放松吧。（虽然被晒得黑了两度！）可以看到页面最上面的背景照片就是我这次在厦门的一个沙滩所拍摄的！在这次更新中我觉得好看就放了上去，接下来谈谈这次的主题更新！</p><h3 id="2-主题更换"><a href="#2-主题更换" class="headerlink" title="2:主题更换"></a>2:主题更换</h3><p> &emsp;&emsp;之前的主题一直用的是next主题，虽然网上的教程很多，但是无论什么样式看来看去真的很丑，所以最近几天就下决心换了一个主题，目前的样式就是所更换之后的主题，是一个中国程序员所编写的BlueLake主题，整个过程他在自己的github主题中写的很详细了，配置也不算太麻烦，感觉比之前的next主题好配置，（也可能我是更熟悉应用了）。所以整个过程没有之前费脑。目前我加上去的最好的功能感觉就是gittalk评论了，但是需要你登录自己的github账号，然后才能评论。我大部分配置的时间是花在了自定义blog的风格上面，这个主题和手机的适配真的也很好，这里就不具体讲这个blog的构造了，可以随处逛逛来自己理解！</p><h3 id="3：日后再要加上的功能"><a href="#3：日后再要加上的功能" class="headerlink" title="3：日后再要加上的功能"></a>3：日后再要加上的功能</h3><p> &emsp;&emsp;目前计划加上的功能有:<br><br> 1:微信支付宝的打赏功能<br><br> 2:被百度搜索引擎收录,并能查询到我的blog(目前已经被谷歌收录)</p><h2 id="二：一些说明"><a href="#二：一些说明" class="headerlink" title="二：一些说明"></a>二：一些说明</h2><h3 id="1：博客给谁看？"><a href="#1：博客给谁看？" class="headerlink" title="1：博客给谁看？"></a>1：博客给谁看？</h3><p>&emsp;&emsp;在我写完这篇blog之前，我几乎没有公开过，甚至于我的舍友看了我的github才知道我写blog。原因首先是因为我的文章数目不够，当别人进来看的时候会不明白我的博客是用来做什么的，其次，我觉得我也没做好准备，目前了解和掌握的“技能点”很少，怕坚持不了第二点说明就自己投降了，<strong>没错重点是第二点说明：</strong></p><h3 id="2：每天写blog！"><a href="#2：每天写blog！" class="headerlink" title="2：每天写blog！"></a>2：每天写blog！</h3><p>&emsp;&emsp;嗯，从今天开始，也就是中国的情人节七夕，以后每天写一篇blog，一直到我写得不想写为止！我将受到所有人的共同监督！<br><br>&emsp;&emsp;<strong>今天的blog算是一个继往开来的第零篇，摆脱过去，重新开始！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一：主题更换&quot;&gt;&lt;a href=&quot;#一：主题更换&quot; class=&quot;headerlink&quot; title=&quot;一：主题更换&quot;&gt;&lt;/a&gt;一：主题更换&lt;/h2&gt;&lt;h3 id=&quot;1：前情概要&quot;&gt;&lt;a href=&quot;#1：前情概要&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="其它" scheme="http://www.simbleman.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>非常艰难的填坑之路</title>
    <link href="http://www.simbleman.com/2019/03/31/%E9%9D%9E%E5%B8%B8%E8%89%B0%E9%9A%BE%E7%9A%84%E5%A1%AB%E5%9D%91%E4%B9%8B%E8%B7%AF/"/>
    <id>http://www.simbleman.com/2019/03/31/非常艰难的填坑之路/</id>
    <published>2019-03-31T08:28:45.000Z</published>
    <updated>2019-08-07T11:36:48.352Z</updated>
    
    <content type="html"><![CDATA[<p><font size="4"><br>    除了吃饭睡觉，这一天都在填一个其实只要用3行代码解决的坑，这中间伴随着郁闷和无尽的郁闷，甚至到达了怀疑自我的境界。。不过还好就在刚刚成功解决了。现在怀着非常激动的心情来叙说这个艰难的过程的结果。<br></font></p><h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><p>这个坑是有关JSON数据处理的，本来一点不了解这个数据格式的，上次在做微信小程序的时候偶然了解到了它，在做这个数据处理前，我以为会很简单。可是正是因为我的忽视，一开始浪费了很多时间在做无谓的工作。</p><h3 id="关于json的微信小程序处理"><a href="#关于json的微信小程序处理" class="headerlink" title="关于json的微信小程序处理"></a>关于json的微信小程序处理</h3><p>因为要选择一个客户端测试，所以就借用了微信小程序，要在java服务器中处理微信wx.request中的json数据，在微信小程序的js里面一定要<font color="red">先处理</font>,不然等到它把数据发送到服务器端，会发现输出的一直是[object][object]一直看不到具体的对象的值，这时候叫天不应叫地不灵，无论在服务端怎么处理，都会发现是无用功，超级郁闷。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">具体处理方法：</span><br><span class="line">json.stringify()方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串</span><br><span class="line">json.parse() 方法将数据转换为 JavaScript 对象( 将字符串转成json对象。 )</span><br><span class="line"></span><br><span class="line">js中的数据</span><br><span class="line">data: [&#123; &quot;coorx&quot;: 12, &quot;coory&quot;: 13 &#125;,</span><br><span class="line">    &#123; &quot;coorx&quot;: 123, &quot;coory&quot;: 133 &#125;,</span><br><span class="line">    &#123; &quot;coorx&quot;: 123, &quot;coory&quot;: 133 &#125;</span><br><span class="line">    ]</span><br><span class="line">var arrJosn = JSON.stringify(this.data.data);</span><br><span class="line">传输的数据：</span><br><span class="line">data: &#123;</span><br><span class="line">        &quot;data&quot;: arrJosn</span><br><span class="line">      &#125;,</span><br><span class="line">只有这样data传到服务端才能正常显示，真坑啊。</span><br></pre></td></tr></table></figure></p><h3 id="服务端的处理"><a href="#服务端的处理" class="headerlink" title="服务端的处理"></a>服务端的处理</h3><p>在服务端发现是小程序中的json未处理前，在服务端我几乎把所有json处理的方式都试了一遍，但是没有效果。。但是试完了之后发现自己对json这个数据类型处理的思路也很清晰了。<br>我用的是阿里巴巴的fastjson库。<br>不过仔细想想我还是没有明白那个困惑我很久的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    private static final String  JSON_ARRAY_STR = &quot;[&#123;\&quot;coory\&quot;:13,\&quot;coorx\&quot;:12&#125;,&#123;\&quot;coory\&quot;:13,\&quot;coorx\&quot;:12&#125;,&#123;\&quot;coory\&quot;:13,\&quot;coorx\&quot;:12&#125;]&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        JSONArray jsonArray = JSON.parseArray(JSON_ARRAY_STR);</span><br><span class="line">        System.out.println(jsonArray);</span><br><span class="line">&#125;</span><br><span class="line">以上代码运行一点问题都没有</span><br><span class="line">但是如果将JSON_ARRAY_STR变成另一种方法得到的，输出就会一直报错。</span><br><span class="line">    JSONArray jsonArray = new JSONArray();</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            JSONObject jsonObject = new JSONObject();</span><br><span class="line">            jsonObject.put(&quot;coorx&quot;, 12);</span><br><span class="line">            jsonObject.put(&quot;coory&quot;, 13);</span><br><span class="line">            jsonArray.add(jsonObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String str=jsonArray.toJSONString();</span><br><span class="line">    String JSON_ARRAY_STR=JSON.toJSONString(str);</span><br><span class="line">    JSONArray jsa=JSON.parseArray(JSON_ARRAY_STR);</span><br><span class="line">    执行到最后一句一直报Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: syntax error, expect [, actual string, pos 0, fieldName null</span><br><span class="line">    但是你输出str2跟上面一种方法的JSON_ARRAY_STR一模一样。</span><br><span class="line">    无解啊</span><br></pre></td></tr></table></figure></p><p>最后成功解决的原因就是不用把微信小程序处理过的数据再toJSONString。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String coor=request.getParameter(&quot;data&quot;);</span><br><span class="line">JSONArray jsa=JSONArray.parseArray(coor);</span><br><span class="line">这里直接parseArray于是就成功了转换成了json数组了。</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个坑的主要问题就是上面这些，虽然有些时候很多坑填填是必要的，但是这次的填坑之旅花费了大量的时间，而且非常艰难，这是我对这个问题的简单化造成的，一开始并没有想很系统的去了解和解决这个问题，总是想着网上copy其他人的代码节省时间，现在才发现自己去了解其中的原因和道理才是真正省时间的方法。嗯..还有很多问题等着去解决呢，还是不废话了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;4&quot;&gt;&lt;br&gt;    除了吃饭睡觉，这一天都在填一个其实只要用3行代码解决的坑，这中间伴随着郁闷和无尽的郁闷，甚至到达了怀疑自我的境界。。不过还好就在刚刚成功解决了。现在怀着非常激动的心情来叙说这个艰难的过程的结果。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="微信小程序" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="json" scheme="http://www.simbleman.com/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>队列的实现</title>
    <link href="http://www.simbleman.com/2019/03/26/%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.simbleman.com/2019/03/26/队列的实现/</id>
    <published>2019-03-26T05:47:43.000Z</published>
    <updated>2019-08-07T11:36:17.060Z</updated>
    
    <content type="html"><![CDATA[<font size="4"><br>    队列也是一种特殊的线性表，它的特点是先进先出，所有的插入操作都在表的一端进行，而删除操作都在表的另一端进行，<br></font><h2 id="队列的指针实现"><a href="#队列的指针实现" class="headerlink" title="队列的指针实现"></a>队列的指针实现</h2><p>因为队列要在线性表的两段进行操作，为了方便使用，就不能像栈那样只有个节点型就好了，因此它的定义和栈会有不同。</p><h3 id="队列的定义和初始化"><a href="#队列的定义和初始化" class="headerlink" title="队列的定义和初始化"></a>队列的定义和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">队列的节点定义</span><br><span class="line">struct node&#123;</span><br><span class="line">    node *next;</span><br><span class="line">    int element;</span><br><span class="line">&#125;;</span><br><span class="line">队列的定义</span><br><span class="line">struct QUEUE&#123;</span><br><span class="line">    node * front;//表头节点</span><br><span class="line">    node * rear;//指向最后一个元素的节点</span><br><span class="line">&#125;;</span><br><span class="line">初始化</span><br><span class="line">void init(QUEUE &amp;q)&#123;//初始化为空表，头指针和尾指针重合 </span><br><span class="line">    q.front=new node;</span><br><span class="line">    q.front-&gt;next=NULL;</span><br><span class="line">    q.rear=q.front;</span><br><span class="line">    cout&lt;&lt;&quot;初始化成功&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作（在队列的尾部进行）"><a href="#插入操作（在队列的尾部进行）" class="headerlink" title="插入操作（在队列的尾部进行）"></a>插入操作（在队列的尾部进行）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void enqueue(int x,QUEUE &amp;q)&#123;</span><br><span class="line">    q.rear-&gt;next=new node;</span><br><span class="line">    q.rear=q.rear-&gt;next;</span><br><span class="line">    q.rear-&gt;next=NULL;</span><br><span class="line">    q.rear-&gt;element=x;</span><br><span class="line">    cout&lt;&lt;&quot;插入队列成功&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作（在队列的头部进行）"><a href="#删除操作（在队列的头部进行）" class="headerlink" title="删除操作（在队列的头部进行）"></a>删除操作（在队列的头部进行）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void dequeue(QUEUE &amp;q)&#123;</span><br><span class="line">    node * temp;</span><br><span class="line">    if(q.rear==q.front)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该队列为空！&quot;&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        temp=q.front-&gt;next;</span><br><span class="line">        q.front-&gt;next=temp-&gt;next;</span><br><span class="line">        delete temp; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列的数组实现（循环数组）"><a href="#队列的数组实现（循环数组）" class="headerlink" title="队列的数组实现（循环数组）"></a>队列的数组实现（循环数组）</h2><p>因为队列的特殊性，一般的数组难以满足完美地满足它的要求，所以这里用循环数组来实现它。</p><h3 id="队列的定义和初始化-1"><a href="#队列的定义和初始化-1" class="headerlink" title="队列的定义和初始化"></a>队列的定义和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">    int elements[maxlength];</span><br><span class="line">&#125;QUEUE; </span><br><span class="line"></span><br><span class="line">void init(QUEUE &amp;Q)&#123;//将队列置为空 </span><br><span class="line">    Q.front=0;</span><br><span class="line">    Q.rear=maxlength-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：为了防止循环队列队满和队空的状态相同，因此这里将rear比front滞后一个位置做为队空的状态，front为0，rear为maxlength-1，而把rear所指单元比front滞后两个位置做为队满的状态。</p><h3 id="循环数组很重要的addone函数"><a href="#循环数组很重要的addone函数" class="headerlink" title="循环数组很重要的addone函数"></a>循环数组很重要的addone函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addone函数算是实现了循环数组循环的条件</span><br><span class="line">int addone(int i)&#123;</span><br><span class="line">    return ((i+1)%maxlength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作（将rear往前移动一个位置（顺时针））"><a href="#插入操作（将rear往前移动一个位置（顺时针））" class="headerlink" title="插入操作（将rear往前移动一个位置（顺时针））"></a>插入操作（将rear往前移动一个位置（顺时针））</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void insert(QUEUE &amp;Q,int x)&#123;</span><br><span class="line">    if(addone(addone(Q.rear))==Q.front)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该队列已满！&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Q.rear=addone(Q.rear);</span><br><span class="line">        Q.elements[Q.rear]=x;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;&quot;插入队列成功！&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作-将front往前移动一个位置（顺时针）"><a href="#删除操作-将front往前移动一个位置（顺时针）" class="headerlink" title="删除操作(将front往前移动一个位置（顺时针）)"></a>删除操作(将front往前移动一个位置（顺时针）)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void deleteq(QUEUE &amp;q)&#123;</span><br><span class="line">    if(addone(q.rear)==q.front)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该附列已空&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        q.front=addone(q.front);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot;&gt;&lt;br&gt;    队列也是一种特殊的线性表，它的特点是先进先出，所有的插入操作都在表的一端进行，而删除操作都在表的另一端进行，&lt;br&gt;&lt;/font&gt;

&lt;h2 id=&quot;队列的指针实现&quot;&gt;&lt;a href=&quot;#队列的指针实现&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.simbleman.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://www.simbleman.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈的实现</title>
    <link href="http://www.simbleman.com/2019/03/25/%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.simbleman.com/2019/03/25/栈的实现/</id>
    <published>2019-03-25T13:31:20.000Z</published>
    <updated>2019-08-07T11:31:24.114Z</updated>
    
    <content type="html"><![CDATA[<p><font size="4"><br>    栈和队列都是一种特殊的线性表，因此都可以用指针和数组来实现它。在这里只实现他的一些关键的操作函数和方法。<br></font></p><h2 id="栈的数组实现"><a href="#栈的数组实现" class="headerlink" title="栈的数组实现"></a>栈的数组实现</h2><p>栈的数据逻辑特点是先进后出，所以一般用数组的最后位置当做栈的底部，而把数组开头的元素当做栈的顶部，因此入栈也称作压栈，且数据的删除和插入操作都只在栈的一端进行，因此栈的数据结构有int型的top，指向栈顶元素，还有一个数组用于存放栈的元素。</p><h3 id="1：栈的数组结构体定义和初始化"><a href="#1：栈的数组结构体定义和初始化" class="headerlink" title="1：栈的数组结构体定义和初始化"></a>1：栈的数组结构体定义和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const int maxsize=100;</span><br><span class="line">struct STACK&#123;</span><br><span class="line">    int top;</span><br><span class="line">    int elements[maxsize];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void init(STACK &amp;s)&#123;</span><br><span class="line">    s.top=maxsize;//当top为maxsize时，则栈为空 </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-push操作"><a href="#2-push操作" class="headerlink" title="2:push操作"></a>2:push操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void push(STACK &amp;s,int x)&#123;</span><br><span class="line">    if(s.top==0)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该栈已满&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        s.top-=1;</span><br><span class="line">        s.elements[s.top]=x;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;&quot;压栈成功&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-pop操作"><a href="#3-pop操作" class="headerlink" title="3:pop操作"></a>3:pop操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void pop(STACK &amp;s)&#123;</span><br><span class="line">    if(s.top==maxsize)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该栈为空&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        s.top+=1;</span><br><span class="line">        cout&lt;&lt;&quot;出栈成功，已删除栈顶元素&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：其他操作功能可以根据需要进行设计</p><h2 id="栈的指针实现"><a href="#栈的指针实现" class="headerlink" title="栈的指针实现"></a>栈的指针实现</h2><p>栈的指针实现同数组实现，他的数据的插入和删除操作都在表头进行，和数组实现相比没有栈满的情况出现。</p><h3 id="1-结构体定义及初始化"><a href="#1-结构体定义及初始化" class="headerlink" title="1:结构体定义及初始化"></a>1:结构体定义及初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">    node * next;</span><br><span class="line">    int element;</span><br><span class="line">&#125;;</span><br><span class="line">typedef node * STACK;</span><br><span class="line"></span><br><span class="line">void init(STACK &amp;S)&#123;//初始化即将栈置空</span><br><span class="line">    S=new node;</span><br><span class="line">    S-&gt;next=NULL;</span><br><span class="line">    cout&lt;&lt;&quot;初始化成功！&quot;&lt;&lt;endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-push操作-1"><a href="#2-push操作-1" class="headerlink" title="2:push操作"></a>2:push操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void push(STACK &amp;s,int x)&#123;</span><br><span class="line">    STACK stk;</span><br><span class="line">    stk=new node;</span><br><span class="line">    stk-&gt;element=x;</span><br><span class="line">    stk-&gt;next=s-&gt;next;</span><br><span class="line">    s-&gt;next=stk;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;&quot;入栈成功&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-pop操作-1"><a href="#3-pop操作-1" class="headerlink" title="3:pop操作"></a>3:pop操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void pop(STACK &amp;s)&#123;</span><br><span class="line">    STACK stk;</span><br><span class="line">    cout&lt;&lt;s-&gt;next-&gt;element&lt;&lt;&quot;出栈成功！&quot;&lt;&lt;endl; </span><br><span class="line">    if(s-&gt;next!=NULL)&#123;</span><br><span class="line">        stk=s-&gt;next;</span><br><span class="line">        s-&gt;next=stk-&gt;next;</span><br><span class="line">        delete stk;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该栈为空&quot;&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;4&quot;&gt;&lt;br&gt;    栈和队列都是一种特殊的线性表，因此都可以用指针和数组来实现它。在这里只实现他的一些关键的操作函数和方法。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;栈的数组实现&quot;&gt;&lt;a href=&quot;#栈的数组实现&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.simbleman.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="http://www.simbleman.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>线性表的实现</title>
    <link href="http://www.simbleman.com/2019/03/18/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.simbleman.com/2019/03/18/线性表的实现/</id>
    <published>2019-03-18T11:52:53.000Z</published>
    <updated>2019-08-07T11:30:34.350Z</updated>
    
    <content type="html"><![CDATA[<font size="4"><br>最近在学习“数据结构和算法”这门课，刚学到了线性表这边，于是自己就课后用C++写了一下，但并没有用类的方式写它，单纯的用C的语言完成的，但写完后才发现跟自己在课上理解的所谓的线性表完全不一样。。<br></font><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>线性表的实现可以分为数组的实现和指针的实现，也称作顺序表和链表。这两种方法各有各的优缺点，但在这里要区分一下概念，一般我们所说的线性表是逻辑结构，顺序表和链表是存储结构。</p><h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><p>本来想讲一讲struct的使用方法的，不过感觉有点偏离主题了，这里可以给出<a href="http://blog.sina.com.cn/s/blog_4fdabc820100fsxu.html" target="_blank" rel="noopener">struct参考文章</a>，其实只要了解和学习C++中的使用方法就基本可以了,如果有需要再去了解C语言中的用法。<br></p><h3 id="1：结构体定义和初始化"><a href="#1：结构体定义和初始化" class="headerlink" title="1：结构体定义和初始化"></a>1：结构体定义和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define maxlength 100</span><br><span class="line">struct list&#123;</span><br><span class="line">    int elements[maxlength];//这里的int可以换成任何其他的数据类型</span><br><span class="line">    int last;//这是用以指示表中的最后一个元素在数组中的位置</span><br><span class="line">&#125;</span><br><span class="line">注意：数组实现方法中数组的开头不放元素，即elements[0]为空</span><br><span class="line">初始化：</span><br><span class="line">void init(list &amp;l)&#123;</span><br><span class="line">    l.last=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">定义position：typedef int position;</span><br></pre></td></tr></table></figure><h3 id="2-插入和删除元素"><a href="#2-插入和删除元素" class="headerlink" title="2:插入和删除元素"></a>2:插入和删除元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void insertL(list &amp;l,position p,int x)//用形参引用可以改变实参的值 </span><br><span class="line">    &#123;</span><br><span class="line">        if(l.last&gt;=maxlength-1)</span><br><span class="line">            cout&lt;&lt;&quot;Error! The list is full!&quot;;</span><br><span class="line">        else if(p&gt;l.last+1||p&lt;=0)</span><br><span class="line">            cout&lt;&lt;&quot;Error! The position does not exist!&quot;;</span><br><span class="line">        else&#123;</span><br><span class="line">            int i;</span><br><span class="line">            for(i=l.last;i&gt;=p;i--)&#123;</span><br><span class="line">                l.elements[i+1]=l.elements[i];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">                l.last+=1;</span><br><span class="line">                l.elements[p]=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">void deleteL(list &amp;l,position p)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if(p&gt;l.last+1||p&lt;=0)</span><br><span class="line">        cout&lt;&lt;&quot;Error! The position does not exist!&quot;;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(i=p;i&lt;=l.last-1;i++)&#123;</span><br><span class="line">        l.elements[i]=l.elements[i+1];</span><br><span class="line">    &#125;</span><br><span class="line">    l.last-=1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3：元素的查找"><a href="#3：元素的查找" class="headerlink" title="3：元素的查找"></a>3：元素的查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">按值查找：</span><br><span class="line">int locateN(list &amp;l,int x)&#123;</span><br><span class="line">    position q;</span><br><span class="line">    for(q=1;q&lt;=l.last;q++)&#123;</span><br><span class="line">        if(l.elements[q]==x)&#123;</span><br><span class="line">            return q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;//如果不存在就返回一个非正常数字</span><br><span class="line">&#125; </span><br><span class="line">按位查找：</span><br><span class="line">int locateP(list &amp;l,int x)&#123;</span><br><span class="line">    if(x&lt;1||x&gt;l.last)</span><br><span class="line">        cout&lt;&lt;&quot;不存在这个位置的数据&quot;&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">        return l.elements[x]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：其他功能可以根据需要自己实现，这里就不一一实现了</p><h2 id="指针实现"><a href="#指针实现" class="headerlink" title="指针实现"></a>指针实现</h2><p>线性表的指针实现主要是靠一个一个节点连接起来的，所以了解节点的概念很重要，还有一些C语言中用到的或者已经遗忘的知识点，这里简单回忆下<a href="https://blog.csdn.net/xxpresent/article/details/53024555" target="_blank" rel="noopener">new的用法</a>，new是在C++中使用的动态内存分配，一般是给指针分配内存。底层调用malloc，返回的是void*指针类型。</p><h3 id="1-结构体定义"><a href="#1-结构体定义" class="headerlink" title="1:结构体定义"></a>1:结构体定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> struct node&#123;</span><br><span class="line">    node * next;</span><br><span class="line">    int element;</span><br><span class="line">&#125;;</span><br><span class="line">typedef node * LIST;</span><br><span class="line">typedef node * position;</span><br></pre></td></tr></table></figure><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2:初始化"></a>2:初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void init(LIST &amp;l)&#123;//参数必须要为引用或者为一个指针 若为指针时，则传过来的实参要为地址 </span><br><span class="line">    l=new node;</span><br><span class="line">    //l=(LIST)malloc(sizeof(node));//malloc返回的是一个指针，等于从内存中获取空间 </span><br><span class="line">    l-&gt;next=NULL;</span><br><span class="line">    l-&gt;element=2;</span><br><span class="line">&#125;</span><br><span class="line">注：这里用new和malloc都可以的</span><br></pre></td></tr></table></figure><h3 id="3-插入和删除元素"><a href="#3-插入和删除元素" class="headerlink" title="3:插入和删除元素"></a>3:插入和删除元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">bool insert(int x,int p,LIST &amp;l)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    LIST L=l;</span><br><span class="line">    LIST s;</span><br><span class="line">    for(i=1;i&lt;p;i++)&#123;</span><br><span class="line">        L=L-&gt;next;</span><br><span class="line">        if(L==NULL)</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    s=(LIST)malloc(sizeof(node));</span><br><span class="line">    s-&gt;next=L-&gt;next;</span><br><span class="line">    L-&gt;next=s;</span><br><span class="line">    s-&gt;element=x;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">注：p是指的第几个位置，其实时间复杂度只有O(1);</span><br><span class="line">分开写：</span><br><span class="line">void insertl(int x,position p)&#123;//实际的插入函数，复杂度只有O(1)</span><br><span class="line">    position s;</span><br><span class="line">    s=(LIST)malloc(sizeof(node));</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    s-&gt;element=x;</span><br><span class="line">    cout&lt;&lt;&quot;插入成功！&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">bool insert(int x,int p,LIST &amp;l)&#123;//用来寻找position p</span><br><span class="line">    int i;</span><br><span class="line">    LIST L=l;</span><br><span class="line">    for(i=1;i&lt;p;i++)&#123;</span><br><span class="line">        L=L-&gt;next;</span><br><span class="line">        if(L==NULL)</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    insertl(x,L);</span><br><span class="line">    return true;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool deletel(int p,LIST &amp;l)&#123;//跟insert道理类似</span><br><span class="line">    int i;</span><br><span class="line">    LIST L=l;</span><br><span class="line">    LIST temp;</span><br><span class="line">    for(i=1;i&lt;p;i++)&#123;</span><br><span class="line">        L=L-&gt;next;</span><br><span class="line">        if(L==NULL)</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    temp=L-&gt;next;</span><br><span class="line">    L-&gt;next=temp-&gt;next;</span><br><span class="line">    delete temp;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-查找元素"><a href="#4-查找元素" class="headerlink" title="4:查找元素"></a>4:查找元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">position locate(int x,LIST &amp;L)&#123;</span><br><span class="line">    position p;</span><br><span class="line">    p=L;</span><br><span class="line">    while(p-&gt;next!=NULL)&#123;</span><br><span class="line">        if(p-&gt;next-&gt;element==x)&#123;</span><br><span class="line">            return p;  //返回的是要查找元素的前一个位置 </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>顺序存储特点：长度固定，不易扩充，插入删除费时间O(n)，估算长度，浪费空间<br><br>链式存储特点：长度灵活可变，易扩充，访问元素费时间O(n)，实际长度，节省空间。<br><br>数组实现的方式中逻辑结构和物理结构相同，是连续的存储空间，而指针时不连续的存储空间。目前看来其实简单的线性表还是用数组实现更好，因为指针实现的insert和delete还要去找它的position，目前在我看来依旧很费时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot;&gt;&lt;br&gt;最近在学习“数据结构和算法”这门课，刚学到了线性表这边，于是自己就课后用C++写了一下，但并没有用类的方式写它，单纯的用C的语言完成的，但写完后才发现跟自己在课上理解的所谓的线性表完全不一样。。&lt;br&gt;&lt;/font&gt;

&lt;h2 id=&quot;分类&quot;
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.simbleman.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表" scheme="http://www.simbleman.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>好久没更新了</title>
    <link href="http://www.simbleman.com/2019/03/12/%E5%A5%BD%E4%B9%85%E6%B2%A1%E6%9B%B4%E6%96%B0%E4%BA%86/"/>
    <id>http://www.simbleman.com/2019/03/12/好久没更新了/</id>
    <published>2019-03-12T13:11:31.000Z</published>
    <updated>2019-08-07T11:30:05.167Z</updated>
    
    <content type="html"><![CDATA[<font size="4"><br>    已经快有一个月没有更新了，有点惭愧。<br><br>    主要是从准备开学到正式开学，一直都在做一个关于微信小程序的小项目，以前完全没有这方面的学习经历和经验，所以就从web的前端和后端一直看到了微信小程序。这其中总感觉时间不够用，所以一直很赶时间，就没有来更新博客了，但事实也证明了时间是不够用的。虽然这个小项目可能不会很完美结束，但这一个月还是学到了不少的。接下来我会尽量缩短我更新博客的时间，将这个月的经历一一分享。<br><br><br><br><br><br></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot;&gt;&lt;br&gt;    已经快有一个月没有更新了，有点惭愧。&lt;br&gt;&lt;br&gt;    主要是从准备开学到正式开学，一直都在做一个关于微信小程序的小项目，以前完全没有这方面的学习经历和经验，所以就从web的前端和后端一直看到了微信小程序。这其中总感觉时间不够用，
      
    
    </summary>
    
      <category term="其它" scheme="http://www.simbleman.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux的正则表达式基础</title>
    <link href="http://www.simbleman.com/2019/02/17/Linux%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.simbleman.com/2019/02/17/Linux的正则表达式基础/</id>
    <published>2019-02-17T07:24:45.000Z</published>
    <updated>2019-08-07T11:27:43.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><font size="4">在认识和学习bash的过程中，其中的通配符和让我印象深刻，当我了解到正则表达式时，它的功能同样让我感到惊讶，他们的相似之处有很多很多，因此经常会混淆他们的用法，但是这两者是完全不一样的东西！根据我的理解，通配符就像是bash中的特殊符号，可以直接被bash识别，最常用的用法是配合ls命令，进行查询操作的功能。而正则表达式则是一种字符串处理的表示方法，有很强大的字符串处理能力，可以信息进行加工和处理从而呈现出自己想要的信息。因为目前最经常用到的字符串选取工具程序是grep，所以就先用grep介绍最基本的正则表达式。</font><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><font size="4">先给出grep常用的语法参数：</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c:&quot;查找字符串&quot;的次数</span><br><span class="line">-i: 忽略大小写的不同</span><br><span class="line">-n: 输出行号</span><br><span class="line">-v: 反向选择</span><br><span class="line">-A: (after)后面可加数字n，表示将后面的n行列出来</span><br><span class="line">-B: (before)前面可加数字n,表示将前面的n行列出来</span><br></pre></td></tr></table></figure><br><br>假设目标文件为text.txt<br><br><font size="4">1：查找特定字符串</font><p><code>grep -in &#39;the&#39; text.txt</code> 查找文件中包含大小写the的字符串的所有行，并打印行号</p><p><code>grep -vn &#39;the&#39; text.txt</code> 查找文件中不含the的字符串的所有行</p><font size="4">2：利用中括号查找字符集合</font><p><code>grep -n &#39;t[ae]st&#39; text.txt</code> 查找文件中包含tast或者test的字符串的所有行</p><p><code>grep -nA3 &#39;[^g]00&#39; text.txt</code> 查找文件中包含oo字符串且前面没有字母g的的所有行，并且还输出符合条件行的后面三行。</p><p><code>grep -n &#39;[^a-z]oo&#39; text.txt</code> 查找包含oo字符串，并且oo之前没有小写字母</p><p><strong>注：小写字母还可以用[:lower:]表示，即</strong><code>[^a-z]等同于[^[:lower:]]</code><strong>不过初入门可以不用记忆太多，暂且先不列出这种特殊符号。</strong></p><font size="4">3:任意一个字符”.”</font><p><code>grep -n &#39;g..d&#39; text.txt</code> 选取含有g??d的字符串，即共有4个字符的所有行</p><font size="4">4：重复字符”*”</font><p><code>grep -n &#39;roo*t&#39; text.txt</code> 选取含有以r开头t结尾且中间必定含有一个o的字符串，’ro*t’<br>表示r和t中间可以含有零到无穷个o</p><p><strong>注：如果想得到g开头和g结尾的字符串，我们经常会写成</strong><code>grep -n &#39;g*g&#39; text.txt</code><strong>而这个表示选取含有字母g的那一行，因为 g* 表示是空字符或者含有一个即以上的g。</strong><br><strong>要想得到符合要求的字符串要写成</strong><br><code>grep -n &#39;g.*&#39;g text.txt</code>                       <strong>因为”.”表示的是任意一个字符,所以 .* 表示零个或任意一个字符的意思。</strong></p><font size="4">5：行首和行尾字符</font><p><code>grep -n &#39;^the&#39; text.txt</code> 查找行首有the的所有行</p><p><code>grep -n &#39;^[a-z]&#39; text.txt</code> 查找行首是小写字母的所有行</p><p><code>grep -n &#39;^[^a-zA-Z]&#39; text.txt</code> 查找行首不是英文字母的所有行</p><p>这里注意^在[]里面和外面的不同含义哦！</p><p><strong>注：Linux里面的断行符是”$”,而windows中的断行符为”^M$”,所以行尾的标识符为$</strong></p><p><code>grep -n &#39;\.$&#39; text.txt</code> 选取文本中以”.”（英文句号）结尾的所有行，这里的\是转义字符，”\.”表示解除”.”的特殊含义</p><p><code>grep -n &#39;^$&#39; text.txt</code> 表示选取所有的空白行</p><h2 id="综上所述，基础正则表达式字符："><a href="#综上所述，基础正则表达式字符：" class="headerlink" title="综上所述，基础正则表达式字符："></a>综上所述，基础正则表达式字符：</h2><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">意义 </th></tr></thead><tbody><tr><td style="text-align:center">^word</td><td style="text-align:center">要查找的字符串在行首 </td></tr><tr><td style="text-align:center">word$</td><td style="text-align:center">要查找的字符串在行尾</td></tr><tr><td style="text-align:center">.(小数点)</td><td style="text-align:center">代表一定有一个任意字符的字符</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">转义字符</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">重复前一个字符零次或者无数次</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:center">从[]集合里面选出一个想要的字符</td></tr><tr><td style="text-align:center">[n1-n2]</td><td style="text-align:center">从n1到n2中选取一个想要的字符</td></tr><tr><td style="text-align:center">[^]</td><td style="text-align:center">从集合里面找出不要的字符串</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h2&gt;&lt;font size=&quot;4&quot;&gt;在认识和学习bash的过程中，其中的通配符和让我印象深刻，当我了解到正则表达式时，它的功能同样让我感到惊讶，他们
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Linux" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.simbleman.com/tags/Linux/"/>
    
      <category term="正则表达式" scheme="http://www.simbleman.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.simbleman.com/2019/02/16/hello-world/"/>
    <id>http://www.simbleman.com/2019/02/16/hello-world/</id>
    <published>2019-02-15T16:22:17.208Z</published>
    <updated>2019-08-07T10:47:22.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欢迎来到我的个人临时博客"><a href="#欢迎来到我的个人临时博客" class="headerlink" title="欢迎来到我的个人临时博客"></a>欢迎来到我的个人临时博客</h2><h3 id="想着总要做点什么"><a href="#想着总要做点什么" class="headerlink" title="想着总要做点什么"></a>想着总要做点什么</h3><font size="4"><br>大一也像模像样的在阿里云上搞了一个传统的网站博客<br><br>不过那只是出于好奇和尝试 那时什么也不懂什么也不会<br><br>最后费时费力还费钱就没有继续搞下去了<br><br>到了大二就想着总要做点什么<br><br>于是就开始了重建之路<br><br>为了节约和方便 现在的博客是基于托管服务的<br><br>所以外观和界面都很简陋<br><br>我也在不断地完善之中<br><br>暂时就着当做是临时博客吧<br><br></font><h3 id="成长还来得及"><a href="#成长还来得及" class="headerlink" title="成长还来得及"></a>成长还来得及</h3><font size="4"><br>还记得大一上刚学<font color="#FF7F50 "><code>C++</code></font>的时候<br><br>从最一开始很吃力地写<font color="#FF7F50 "><code>Hello World</code> </font>到后来期末跟同学写小项目<br> 跨越的过程还是花了很多时间和精力的<br><br>不过也感觉到了自己的成长<br><br>可能这将是一个漫长的过程<br><br>所以希望能用博客记录我的成长和收获<br><br>我也会将自己的心得和感想随时分享…<br></font><h3 id="欢迎指正"><a href="#欢迎指正" class="headerlink" title="欢迎指正"></a>欢迎指正</h3><font size="4"><br>如果对网站或任何问题有什么意见或建议<br><br>欢迎给我留言和指正<br><br>目前的评论系统正在构建…请耐心等待…<br><br><br><br></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;欢迎来到我的个人临时博客&quot;&gt;&lt;a href=&quot;#欢迎来到我的个人临时博客&quot; class=&quot;headerlink&quot; title=&quot;欢迎来到我的个人临时博客&quot;&gt;&lt;/a&gt;欢迎来到我的个人临时博客&lt;/h2&gt;&lt;h3 id=&quot;想着总要做点什么&quot;&gt;&lt;a href=&quot;#想着总要做
      
    
    </summary>
    
      <category term="其它" scheme="http://www.simbleman.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="Hello World" scheme="http://www.simbleman.com/tags/Hello-World/"/>
    
  </entry>
  
</feed>
