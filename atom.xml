<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Haohao&#39;s Blog</title>
  
  <subtitle>To be a better man.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.simbleman.com/"/>
  <updated>2019-08-07T11:29:15.458Z</updated>
  <id>http://www.simbleman.com/</id>
  
  <author>
    <name>Haoocker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>非常艰难的填坑之路</title>
    <link href="http://www.simbleman.com/2019/03/31/%E9%9D%9E%E5%B8%B8%E8%89%B0%E9%9A%BE%E7%9A%84%E5%A1%AB%E5%9D%91%E4%B9%8B%E8%B7%AF/"/>
    <id>http://www.simbleman.com/2019/03/31/非常艰难的填坑之路/</id>
    <published>2019-03-31T08:28:45.000Z</published>
    <updated>2019-08-07T11:29:15.458Z</updated>
    
    <content type="html"><![CDATA[<p><font size="4"><br>    除了吃饭睡觉，这一天都在填一个其实只要用3行代码解决的坑，这中间伴随着郁闷和无尽的郁闷，甚至到达了怀疑自我的境界。。不过还好就在刚刚成功解决了。现在怀着非常激动的心情来叙说这个艰难的过程的结果。<br></font></p><h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><p>这个坑是有关JSON数据处理的，本来一点不了解这个数据格式的，上次在做微信小程序的时候偶然了解到了它，在做这个数据处理前，我以为会很简单。可是正是因为我的忽视，一开始浪费了很多时间在做无谓的工作。</p><h3 id="关于json的微信小程序处理"><a href="#关于json的微信小程序处理" class="headerlink" title="关于json的微信小程序处理"></a>关于json的微信小程序处理</h3><p>因为要选择一个客户端测试，所以就借用了微信小程序，要在java服务器中处理微信wx.request中的json数据，在微信小程序的js里面一定要<font color="red">先处理</font>,不然等到它把数据发送到服务器端，会发现输出的一直是[object][object]一直看不到具体的对象的值，这时候叫天不应叫地不灵，无论在服务端怎么处理，都会发现是无用功，超级郁闷。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">具体处理方法：</span><br><span class="line">json.stringify()方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串</span><br><span class="line">json.parse() 方法将数据转换为 JavaScript 对象( 将字符串转成json对象。 )</span><br><span class="line"></span><br><span class="line">js中的数据</span><br><span class="line">data: [&#123; &quot;coorx&quot;: 12, &quot;coory&quot;: 13 &#125;,</span><br><span class="line">    &#123; &quot;coorx&quot;: 123, &quot;coory&quot;: 133 &#125;,</span><br><span class="line">    &#123; &quot;coorx&quot;: 123, &quot;coory&quot;: 133 &#125;</span><br><span class="line">    ]</span><br><span class="line">var arrJosn = JSON.stringify(this.data.data);</span><br><span class="line">传输的数据：</span><br><span class="line">data: &#123;</span><br><span class="line">        &quot;data&quot;: arrJosn</span><br><span class="line">      &#125;,</span><br><span class="line">只有这样data传到服务端才能正常显示，真坑啊。</span><br></pre></td></tr></table></figure></p><h3 id="服务端的处理"><a href="#服务端的处理" class="headerlink" title="服务端的处理"></a>服务端的处理</h3><p>在服务端发现是小程序中的json未处理前，在服务端我几乎把所有json处理的方式都试了一遍，但是没有效果。。但是试完了之后发现自己对json这个数据类型处理的思路也很清晰了。<br>我用的是阿里巴巴的fastjson库。<br>不过仔细想想我还是没有明白那个困惑我很久的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    private static final String  JSON_ARRAY_STR = &quot;[&#123;\&quot;coory\&quot;:13,\&quot;coorx\&quot;:12&#125;,&#123;\&quot;coory\&quot;:13,\&quot;coorx\&quot;:12&#125;,&#123;\&quot;coory\&quot;:13,\&quot;coorx\&quot;:12&#125;]&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        JSONArray jsonArray = JSON.parseArray(JSON_ARRAY_STR);</span><br><span class="line">        System.out.println(jsonArray);</span><br><span class="line">&#125;</span><br><span class="line">以上代码运行一点问题都没有</span><br><span class="line">但是如果将JSON_ARRAY_STR变成另一种方法得到的，输出就会一直报错。</span><br><span class="line">    JSONArray jsonArray = new JSONArray();</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            JSONObject jsonObject = new JSONObject();</span><br><span class="line">            jsonObject.put(&quot;coorx&quot;, 12);</span><br><span class="line">            jsonObject.put(&quot;coory&quot;, 13);</span><br><span class="line">            jsonArray.add(jsonObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String str=jsonArray.toJSONString();</span><br><span class="line">    String JSON_ARRAY_STR=JSON.toJSONString(str);</span><br><span class="line">    JSONArray jsa=JSON.parseArray(JSON_ARRAY_STR);</span><br><span class="line">    执行到最后一句一直报Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: syntax error, expect [, actual string, pos 0, fieldName null</span><br><span class="line">    但是你输出str2跟上面一种方法的JSON_ARRAY_STR一模一样。</span><br><span class="line">    无解啊</span><br></pre></td></tr></table></figure></p><p>最后成功解决的原因就是不用把微信小程序处理过的数据再toJSONString。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String coor=request.getParameter(&quot;data&quot;);</span><br><span class="line">JSONArray jsa=JSONArray.parseArray(coor);</span><br><span class="line">这里直接parseArray于是就成功了转换成了json数组了。</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个坑的主要问题就是上面这些，虽然有些时候很多坑填填是必要的，但是这次的填坑之旅花费了大量的时间，而且非常艰难，这是我对这个问题的简单化造成的，一开始并没有想很系统的去了解和解决这个问题，总是想着网上copy其他人的代码节省时间，现在才发现自己去了解其中的原因和道理才是真正省时间的方法。嗯..还有很多问题等着去解决呢，还是不废话了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;4&quot;&gt;&lt;br&gt;    除了吃饭睡觉，这一天都在填一个其实只要用3行代码解决的坑，这中间伴随着郁闷和无尽的郁闷，甚至到达了怀疑自我的境界。。不过还好就在刚刚成功解决了。现在怀着非常激动的心情来叙说这个艰难的过程的结果。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="json" scheme="http://www.simbleman.com/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>队列的实现</title>
    <link href="http://www.simbleman.com/2019/03/26/%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.simbleman.com/2019/03/26/队列的实现/</id>
    <published>2019-03-26T05:47:43.000Z</published>
    <updated>2019-08-07T11:28:41.274Z</updated>
    
    <content type="html"><![CDATA[<font size="4"><br>    队列也是一种特殊的线性表，它的特点是先进先出，所有的插入操作都在表的一端进行，而删除操作都在表的另一端进行，<br></font><h2 id="队列的指针实现"><a href="#队列的指针实现" class="headerlink" title="队列的指针实现"></a>队列的指针实现</h2><p>因为队列要在线性表的两段进行操作，为了方便使用，就不能像栈那样只有个节点型就好了，因此它的定义和栈会有不同。</p><h3 id="队列的定义和初始化"><a href="#队列的定义和初始化" class="headerlink" title="队列的定义和初始化"></a>队列的定义和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">队列的节点定义</span><br><span class="line">struct node&#123;</span><br><span class="line">    node *next;</span><br><span class="line">    int element;</span><br><span class="line">&#125;;</span><br><span class="line">队列的定义</span><br><span class="line">struct QUEUE&#123;</span><br><span class="line">    node * front;//表头节点</span><br><span class="line">    node * rear;//指向最后一个元素的节点</span><br><span class="line">&#125;;</span><br><span class="line">初始化</span><br><span class="line">void init(QUEUE &amp;q)&#123;//初始化为空表，头指针和尾指针重合 </span><br><span class="line">    q.front=new node;</span><br><span class="line">    q.front-&gt;next=NULL;</span><br><span class="line">    q.rear=q.front;</span><br><span class="line">    cout&lt;&lt;&quot;初始化成功&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作（在队列的尾部进行）"><a href="#插入操作（在队列的尾部进行）" class="headerlink" title="插入操作（在队列的尾部进行）"></a>插入操作（在队列的尾部进行）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void enqueue(int x,QUEUE &amp;q)&#123;</span><br><span class="line">    q.rear-&gt;next=new node;</span><br><span class="line">    q.rear=q.rear-&gt;next;</span><br><span class="line">    q.rear-&gt;next=NULL;</span><br><span class="line">    q.rear-&gt;element=x;</span><br><span class="line">    cout&lt;&lt;&quot;插入队列成功&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作（在队列的头部进行）"><a href="#删除操作（在队列的头部进行）" class="headerlink" title="删除操作（在队列的头部进行）"></a>删除操作（在队列的头部进行）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void dequeue(QUEUE &amp;q)&#123;</span><br><span class="line">    node * temp;</span><br><span class="line">    if(q.rear==q.front)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该队列为空！&quot;&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        temp=q.front-&gt;next;</span><br><span class="line">        q.front-&gt;next=temp-&gt;next;</span><br><span class="line">        delete temp; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列的数组实现（循环数组）"><a href="#队列的数组实现（循环数组）" class="headerlink" title="队列的数组实现（循环数组）"></a>队列的数组实现（循环数组）</h2><p>因为队列的特殊性，一般的数组难以满足完美地满足它的要求，所以这里用循环数组来实现它。</p><h3 id="队列的定义和初始化-1"><a href="#队列的定义和初始化-1" class="headerlink" title="队列的定义和初始化"></a>队列的定义和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">    int elements[maxlength];</span><br><span class="line">&#125;QUEUE; </span><br><span class="line"></span><br><span class="line">void init(QUEUE &amp;Q)&#123;//将队列置为空 </span><br><span class="line">    Q.front=0;</span><br><span class="line">    Q.rear=maxlength-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：为了防止循环队列队满和队空的状态相同，因此这里将rear比front滞后一个位置做为队空的状态，front为0，rear为maxlength-1，而把rear所指单元比front滞后两个位置做为队满的状态。</p><h3 id="循环数组很重要的addone函数"><a href="#循环数组很重要的addone函数" class="headerlink" title="循环数组很重要的addone函数"></a>循环数组很重要的addone函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addone函数算是实现了循环数组循环的条件</span><br><span class="line">int addone(int i)&#123;</span><br><span class="line">    return ((i+1)%maxlength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作（将rear往前移动一个位置（顺时针））"><a href="#插入操作（将rear往前移动一个位置（顺时针））" class="headerlink" title="插入操作（将rear往前移动一个位置（顺时针））"></a>插入操作（将rear往前移动一个位置（顺时针））</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void insert(QUEUE &amp;Q,int x)&#123;</span><br><span class="line">    if(addone(addone(Q.rear))==Q.front)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该队列已满！&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Q.rear=addone(Q.rear);</span><br><span class="line">        Q.elements[Q.rear]=x;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;&quot;插入队列成功！&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作-将front往前移动一个位置（顺时针）"><a href="#删除操作-将front往前移动一个位置（顺时针）" class="headerlink" title="删除操作(将front往前移动一个位置（顺时针）)"></a>删除操作(将front往前移动一个位置（顺时针）)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void deleteq(QUEUE &amp;q)&#123;</span><br><span class="line">    if(addone(q.rear)==q.front)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该附列已空&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        q.front=addone(q.front);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot;&gt;&lt;br&gt;    队列也是一种特殊的线性表，它的特点是先进先出，所有的插入操作都在表的一端进行，而删除操作都在表的另一端进行，&lt;br&gt;&lt;/font&gt;

&lt;h2 id=&quot;队列的指针实现&quot;&gt;&lt;a href=&quot;#队列的指针实现&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://www.simbleman.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://www.simbleman.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈的实现</title>
    <link href="http://www.simbleman.com/2019/03/25/%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.simbleman.com/2019/03/25/栈的实现/</id>
    <published>2019-03-25T13:31:20.000Z</published>
    <updated>2019-08-07T11:31:24.114Z</updated>
    
    <content type="html"><![CDATA[<p><font size="4"><br>    栈和队列都是一种特殊的线性表，因此都可以用指针和数组来实现它。在这里只实现他的一些关键的操作函数和方法。<br></font></p><h2 id="栈的数组实现"><a href="#栈的数组实现" class="headerlink" title="栈的数组实现"></a>栈的数组实现</h2><p>栈的数据逻辑特点是先进后出，所以一般用数组的最后位置当做栈的底部，而把数组开头的元素当做栈的顶部，因此入栈也称作压栈，且数据的删除和插入操作都只在栈的一端进行，因此栈的数据结构有int型的top，指向栈顶元素，还有一个数组用于存放栈的元素。</p><h3 id="1：栈的数组结构体定义和初始化"><a href="#1：栈的数组结构体定义和初始化" class="headerlink" title="1：栈的数组结构体定义和初始化"></a>1：栈的数组结构体定义和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const int maxsize=100;</span><br><span class="line">struct STACK&#123;</span><br><span class="line">    int top;</span><br><span class="line">    int elements[maxsize];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void init(STACK &amp;s)&#123;</span><br><span class="line">    s.top=maxsize;//当top为maxsize时，则栈为空 </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-push操作"><a href="#2-push操作" class="headerlink" title="2:push操作"></a>2:push操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void push(STACK &amp;s,int x)&#123;</span><br><span class="line">    if(s.top==0)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该栈已满&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        s.top-=1;</span><br><span class="line">        s.elements[s.top]=x;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;&quot;压栈成功&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-pop操作"><a href="#3-pop操作" class="headerlink" title="3:pop操作"></a>3:pop操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void pop(STACK &amp;s)&#123;</span><br><span class="line">    if(s.top==maxsize)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该栈为空&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        s.top+=1;</span><br><span class="line">        cout&lt;&lt;&quot;出栈成功，已删除栈顶元素&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：其他操作功能可以根据需要进行设计</p><h2 id="栈的指针实现"><a href="#栈的指针实现" class="headerlink" title="栈的指针实现"></a>栈的指针实现</h2><p>栈的指针实现同数组实现，他的数据的插入和删除操作都在表头进行，和数组实现相比没有栈满的情况出现。</p><h3 id="1-结构体定义及初始化"><a href="#1-结构体定义及初始化" class="headerlink" title="1:结构体定义及初始化"></a>1:结构体定义及初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">    node * next;</span><br><span class="line">    int element;</span><br><span class="line">&#125;;</span><br><span class="line">typedef node * STACK;</span><br><span class="line"></span><br><span class="line">void init(STACK &amp;S)&#123;//初始化即将栈置空</span><br><span class="line">    S=new node;</span><br><span class="line">    S-&gt;next=NULL;</span><br><span class="line">    cout&lt;&lt;&quot;初始化成功！&quot;&lt;&lt;endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-push操作-1"><a href="#2-push操作-1" class="headerlink" title="2:push操作"></a>2:push操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void push(STACK &amp;s,int x)&#123;</span><br><span class="line">    STACK stk;</span><br><span class="line">    stk=new node;</span><br><span class="line">    stk-&gt;element=x;</span><br><span class="line">    stk-&gt;next=s-&gt;next;</span><br><span class="line">    s-&gt;next=stk;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;&quot;入栈成功&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-pop操作-1"><a href="#3-pop操作-1" class="headerlink" title="3:pop操作"></a>3:pop操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void pop(STACK &amp;s)&#123;</span><br><span class="line">    STACK stk;</span><br><span class="line">    cout&lt;&lt;s-&gt;next-&gt;element&lt;&lt;&quot;出栈成功！&quot;&lt;&lt;endl; </span><br><span class="line">    if(s-&gt;next!=NULL)&#123;</span><br><span class="line">        stk=s-&gt;next;</span><br><span class="line">        s-&gt;next=stk-&gt;next;</span><br><span class="line">        delete stk;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该栈为空&quot;&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;4&quot;&gt;&lt;br&gt;    栈和队列都是一种特殊的线性表，因此都可以用指针和数组来实现它。在这里只实现他的一些关键的操作函数和方法。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;栈的数组实现&quot;&gt;&lt;a href=&quot;#栈的数组实现&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.simbleman.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="http://www.simbleman.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>线性表的实现</title>
    <link href="http://www.simbleman.com/2019/03/18/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.simbleman.com/2019/03/18/线性表的实现/</id>
    <published>2019-03-18T11:52:53.000Z</published>
    <updated>2019-08-07T11:30:34.350Z</updated>
    
    <content type="html"><![CDATA[<font size="4"><br>最近在学习“数据结构和算法”这门课，刚学到了线性表这边，于是自己就课后用C++写了一下，但并没有用类的方式写它，单纯的用C的语言完成的，但写完后才发现跟自己在课上理解的所谓的线性表完全不一样。。<br></font><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>线性表的实现可以分为数组的实现和指针的实现，也称作顺序表和链表。这两种方法各有各的优缺点，但在这里要区分一下概念，一般我们所说的线性表是逻辑结构，顺序表和链表是存储结构。</p><h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><p>本来想讲一讲struct的使用方法的，不过感觉有点偏离主题了，这里可以给出<a href="http://blog.sina.com.cn/s/blog_4fdabc820100fsxu.html" target="_blank" rel="noopener">struct参考文章</a>，其实只要了解和学习C++中的使用方法就基本可以了,如果有需要再去了解C语言中的用法。<br></p><h3 id="1：结构体定义和初始化"><a href="#1：结构体定义和初始化" class="headerlink" title="1：结构体定义和初始化"></a>1：结构体定义和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define maxlength 100</span><br><span class="line">struct list&#123;</span><br><span class="line">    int elements[maxlength];//这里的int可以换成任何其他的数据类型</span><br><span class="line">    int last;//这是用以指示表中的最后一个元素在数组中的位置</span><br><span class="line">&#125;</span><br><span class="line">注意：数组实现方法中数组的开头不放元素，即elements[0]为空</span><br><span class="line">初始化：</span><br><span class="line">void init(list &amp;l)&#123;</span><br><span class="line">    l.last=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">定义position：typedef int position;</span><br></pre></td></tr></table></figure><h3 id="2-插入和删除元素"><a href="#2-插入和删除元素" class="headerlink" title="2:插入和删除元素"></a>2:插入和删除元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void insertL(list &amp;l,position p,int x)//用形参引用可以改变实参的值 </span><br><span class="line">    &#123;</span><br><span class="line">        if(l.last&gt;=maxlength-1)</span><br><span class="line">            cout&lt;&lt;&quot;Error! The list is full!&quot;;</span><br><span class="line">        else if(p&gt;l.last+1||p&lt;=0)</span><br><span class="line">            cout&lt;&lt;&quot;Error! The position does not exist!&quot;;</span><br><span class="line">        else&#123;</span><br><span class="line">            int i;</span><br><span class="line">            for(i=l.last;i&gt;=p;i--)&#123;</span><br><span class="line">                l.elements[i+1]=l.elements[i];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">                l.last+=1;</span><br><span class="line">                l.elements[p]=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">void deleteL(list &amp;l,position p)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if(p&gt;l.last+1||p&lt;=0)</span><br><span class="line">        cout&lt;&lt;&quot;Error! The position does not exist!&quot;;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(i=p;i&lt;=l.last-1;i++)&#123;</span><br><span class="line">        l.elements[i]=l.elements[i+1];</span><br><span class="line">    &#125;</span><br><span class="line">    l.last-=1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3：元素的查找"><a href="#3：元素的查找" class="headerlink" title="3：元素的查找"></a>3：元素的查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">按值查找：</span><br><span class="line">int locateN(list &amp;l,int x)&#123;</span><br><span class="line">    position q;</span><br><span class="line">    for(q=1;q&lt;=l.last;q++)&#123;</span><br><span class="line">        if(l.elements[q]==x)&#123;</span><br><span class="line">            return q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;//如果不存在就返回一个非正常数字</span><br><span class="line">&#125; </span><br><span class="line">按位查找：</span><br><span class="line">int locateP(list &amp;l,int x)&#123;</span><br><span class="line">    if(x&lt;1||x&gt;l.last)</span><br><span class="line">        cout&lt;&lt;&quot;不存在这个位置的数据&quot;&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">        return l.elements[x]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：其他功能可以根据需要自己实现，这里就不一一实现了</p><h2 id="指针实现"><a href="#指针实现" class="headerlink" title="指针实现"></a>指针实现</h2><p>线性表的指针实现主要是靠一个一个节点连接起来的，所以了解节点的概念很重要，还有一些C语言中用到的或者已经遗忘的知识点，这里简单回忆下<a href="https://blog.csdn.net/xxpresent/article/details/53024555" target="_blank" rel="noopener">new的用法</a>，new是在C++中使用的动态内存分配，一般是给指针分配内存。底层调用malloc，返回的是void*指针类型。</p><h3 id="1-结构体定义"><a href="#1-结构体定义" class="headerlink" title="1:结构体定义"></a>1:结构体定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> struct node&#123;</span><br><span class="line">    node * next;</span><br><span class="line">    int element;</span><br><span class="line">&#125;;</span><br><span class="line">typedef node * LIST;</span><br><span class="line">typedef node * position;</span><br></pre></td></tr></table></figure><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2:初始化"></a>2:初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void init(LIST &amp;l)&#123;//参数必须要为引用或者为一个指针 若为指针时，则传过来的实参要为地址 </span><br><span class="line">    l=new node;</span><br><span class="line">    //l=(LIST)malloc(sizeof(node));//malloc返回的是一个指针，等于从内存中获取空间 </span><br><span class="line">    l-&gt;next=NULL;</span><br><span class="line">    l-&gt;element=2;</span><br><span class="line">&#125;</span><br><span class="line">注：这里用new和malloc都可以的</span><br></pre></td></tr></table></figure><h3 id="3-插入和删除元素"><a href="#3-插入和删除元素" class="headerlink" title="3:插入和删除元素"></a>3:插入和删除元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">bool insert(int x,int p,LIST &amp;l)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    LIST L=l;</span><br><span class="line">    LIST s;</span><br><span class="line">    for(i=1;i&lt;p;i++)&#123;</span><br><span class="line">        L=L-&gt;next;</span><br><span class="line">        if(L==NULL)</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    s=(LIST)malloc(sizeof(node));</span><br><span class="line">    s-&gt;next=L-&gt;next;</span><br><span class="line">    L-&gt;next=s;</span><br><span class="line">    s-&gt;element=x;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">注：p是指的第几个位置，其实时间复杂度只有O(1);</span><br><span class="line">分开写：</span><br><span class="line">void insertl(int x,position p)&#123;//实际的插入函数，复杂度只有O(1)</span><br><span class="line">    position s;</span><br><span class="line">    s=(LIST)malloc(sizeof(node));</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    s-&gt;element=x;</span><br><span class="line">    cout&lt;&lt;&quot;插入成功！&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">bool insert(int x,int p,LIST &amp;l)&#123;//用来寻找position p</span><br><span class="line">    int i;</span><br><span class="line">    LIST L=l;</span><br><span class="line">    for(i=1;i&lt;p;i++)&#123;</span><br><span class="line">        L=L-&gt;next;</span><br><span class="line">        if(L==NULL)</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    insertl(x,L);</span><br><span class="line">    return true;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool deletel(int p,LIST &amp;l)&#123;//跟insert道理类似</span><br><span class="line">    int i;</span><br><span class="line">    LIST L=l;</span><br><span class="line">    LIST temp;</span><br><span class="line">    for(i=1;i&lt;p;i++)&#123;</span><br><span class="line">        L=L-&gt;next;</span><br><span class="line">        if(L==NULL)</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    temp=L-&gt;next;</span><br><span class="line">    L-&gt;next=temp-&gt;next;</span><br><span class="line">    delete temp;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-查找元素"><a href="#4-查找元素" class="headerlink" title="4:查找元素"></a>4:查找元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">position locate(int x,LIST &amp;L)&#123;</span><br><span class="line">    position p;</span><br><span class="line">    p=L;</span><br><span class="line">    while(p-&gt;next!=NULL)&#123;</span><br><span class="line">        if(p-&gt;next-&gt;element==x)&#123;</span><br><span class="line">            return p;  //返回的是要查找元素的前一个位置 </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>顺序存储特点：长度固定，不易扩充，插入删除费时间O(n)，估算长度，浪费空间<br><br>链式存储特点：长度灵活可变，易扩充，访问元素费时间O(n)，实际长度，节省空间。<br><br>数组实现的方式中逻辑结构和物理结构相同，是连续的存储空间，而指针时不连续的存储空间。目前看来其实简单的线性表还是用数组实现更好，因为指针实现的insert和delete还要去找它的position，目前在我看来依旧很费时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot;&gt;&lt;br&gt;最近在学习“数据结构和算法”这门课，刚学到了线性表这边，于是自己就课后用C++写了一下，但并没有用类的方式写它，单纯的用C的语言完成的，但写完后才发现跟自己在课上理解的所谓的线性表完全不一样。。&lt;br&gt;&lt;/font&gt;

&lt;h2 id=&quot;分类&quot;
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.simbleman.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表" scheme="http://www.simbleman.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>好久没更新了</title>
    <link href="http://www.simbleman.com/2019/03/12/%E5%A5%BD%E4%B9%85%E6%B2%A1%E6%9B%B4%E6%96%B0%E4%BA%86/"/>
    <id>http://www.simbleman.com/2019/03/12/好久没更新了/</id>
    <published>2019-03-12T13:11:31.000Z</published>
    <updated>2019-08-07T11:30:05.167Z</updated>
    
    <content type="html"><![CDATA[<font size="4"><br>    已经快有一个月没有更新了，有点惭愧。<br><br>    主要是从准备开学到正式开学，一直都在做一个关于微信小程序的小项目，以前完全没有这方面的学习经历和经验，所以就从web的前端和后端一直看到了微信小程序。这其中总感觉时间不够用，所以一直很赶时间，就没有来更新博客了，但事实也证明了时间是不够用的。虽然这个小项目可能不会很完美结束，但这一个月还是学到了不少的。接下来我会尽量缩短我更新博客的时间，将这个月的经历一一分享。<br><br><br><br><br><br></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot;&gt;&lt;br&gt;    已经快有一个月没有更新了，有点惭愧。&lt;br&gt;&lt;br&gt;    主要是从准备开学到正式开学，一直都在做一个关于微信小程序的小项目，以前完全没有这方面的学习经历和经验，所以就从web的前端和后端一直看到了微信小程序。这其中总感觉时间不够用，
      
    
    </summary>
    
      <category term="其它" scheme="http://www.simbleman.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux的正则表达式基础</title>
    <link href="http://www.simbleman.com/2019/02/17/Linux%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.simbleman.com/2019/02/17/Linux的正则表达式基础/</id>
    <published>2019-02-17T07:24:45.000Z</published>
    <updated>2019-08-07T11:27:43.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><font size="4">在认识和学习bash的过程中，其中的通配符和让我印象深刻，当我了解到正则表达式时，它的功能同样让我感到惊讶，他们的相似之处有很多很多，因此经常会混淆他们的用法，但是这两者是完全不一样的东西！根据我的理解，通配符就像是bash中的特殊符号，可以直接被bash识别，最常用的用法是配合ls命令，进行查询操作的功能。而正则表达式则是一种字符串处理的表示方法，有很强大的字符串处理能力，可以信息进行加工和处理从而呈现出自己想要的信息。因为目前最经常用到的字符串选取工具程序是grep，所以就先用grep介绍最基本的正则表达式。</font><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><font size="4">先给出grep常用的语法参数：</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c:&quot;查找字符串&quot;的次数</span><br><span class="line">-i: 忽略大小写的不同</span><br><span class="line">-n: 输出行号</span><br><span class="line">-v: 反向选择</span><br><span class="line">-A: (after)后面可加数字n，表示将后面的n行列出来</span><br><span class="line">-B: (before)前面可加数字n,表示将前面的n行列出来</span><br></pre></td></tr></table></figure><br><br>假设目标文件为text.txt<br><br><font size="4">1：查找特定字符串</font><p><code>grep -in &#39;the&#39; text.txt</code> 查找文件中包含大小写the的字符串的所有行，并打印行号</p><p><code>grep -vn &#39;the&#39; text.txt</code> 查找文件中不含the的字符串的所有行</p><font size="4">2：利用中括号查找字符集合</font><p><code>grep -n &#39;t[ae]st&#39; text.txt</code> 查找文件中包含tast或者test的字符串的所有行</p><p><code>grep -nA3 &#39;[^g]00&#39; text.txt</code> 查找文件中包含oo字符串且前面没有字母g的的所有行，并且还输出符合条件行的后面三行。</p><p><code>grep -n &#39;[^a-z]oo&#39; text.txt</code> 查找包含oo字符串，并且oo之前没有小写字母</p><p><strong>注：小写字母还可以用[:lower:]表示，即</strong><code>[^a-z]等同于[^[:lower:]]</code><strong>不过初入门可以不用记忆太多，暂且先不列出这种特殊符号。</strong></p><font size="4">3:任意一个字符”.”</font><p><code>grep -n &#39;g..d&#39; text.txt</code> 选取含有g??d的字符串，即共有4个字符的所有行</p><font size="4">4：重复字符”*”</font><p><code>grep -n &#39;roo*t&#39; text.txt</code> 选取含有以r开头t结尾且中间必定含有一个o的字符串，’ro*t’<br>表示r和t中间可以含有零到无穷个o</p><p><strong>注：如果想得到g开头和g结尾的字符串，我们经常会写成</strong><code>grep -n &#39;g*g&#39; text.txt</code><strong>而这个表示选取含有字母g的那一行，因为 g* 表示是空字符或者含有一个即以上的g。</strong><br><strong>要想得到符合要求的字符串要写成</strong><br><code>grep -n &#39;g.*&#39;g text.txt</code>                       <strong>因为”.”表示的是任意一个字符,所以 .* 表示零个或任意一个字符的意思。</strong></p><font size="4">5：行首和行尾字符</font><p><code>grep -n &#39;^the&#39; text.txt</code> 查找行首有the的所有行</p><p><code>grep -n &#39;^[a-z]&#39; text.txt</code> 查找行首是小写字母的所有行</p><p><code>grep -n &#39;^[^a-zA-Z]&#39; text.txt</code> 查找行首不是英文字母的所有行</p><p>这里注意^在[]里面和外面的不同含义哦！</p><p><strong>注：Linux里面的断行符是”$”,而windows中的断行符为”^M$”,所以行尾的标识符为$</strong></p><p><code>grep -n &#39;\.$&#39; text.txt</code> 选取文本中以”.”（英文句号）结尾的所有行，这里的\是转义字符，”\.”表示解除”.”的特殊含义</p><p><code>grep -n &#39;^$&#39; text.txt</code> 表示选取所有的空白行</p><h2 id="综上所述，基础正则表达式字符："><a href="#综上所述，基础正则表达式字符：" class="headerlink" title="综上所述，基础正则表达式字符："></a>综上所述，基础正则表达式字符：</h2><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">意义 </th></tr></thead><tbody><tr><td style="text-align:center">^word</td><td style="text-align:center">要查找的字符串在行首 </td></tr><tr><td style="text-align:center">word$</td><td style="text-align:center">要查找的字符串在行尾</td></tr><tr><td style="text-align:center">.(小数点)</td><td style="text-align:center">代表一定有一个任意字符的字符</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">转义字符</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">重复前一个字符零次或者无数次</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:center">从[]集合里面选出一个想要的字符</td></tr><tr><td style="text-align:center">[n1-n2]</td><td style="text-align:center">从n1到n2中选取一个想要的字符</td></tr><tr><td style="text-align:center">[^]</td><td style="text-align:center">从集合里面找出不要的字符串</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h2&gt;&lt;font size=&quot;4&quot;&gt;在认识和学习bash的过程中，其中的通配符和让我印象深刻，当我了解到正则表达式时，它的功能同样让我感到惊讶，他们
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Linux" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.simbleman.com/tags/Linux/"/>
    
      <category term="正则表达式" scheme="http://www.simbleman.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.simbleman.com/2019/02/16/hello-world/"/>
    <id>http://www.simbleman.com/2019/02/16/hello-world/</id>
    <published>2019-02-15T16:22:17.208Z</published>
    <updated>2019-08-07T10:47:22.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欢迎来到我的个人临时博客"><a href="#欢迎来到我的个人临时博客" class="headerlink" title="欢迎来到我的个人临时博客"></a>欢迎来到我的个人临时博客</h2><h3 id="想着总要做点什么"><a href="#想着总要做点什么" class="headerlink" title="想着总要做点什么"></a>想着总要做点什么</h3><font size="4"><br>大一也像模像样的在阿里云上搞了一个传统的网站博客<br><br>不过那只是出于好奇和尝试 那时什么也不懂什么也不会<br><br>最后费时费力还费钱就没有继续搞下去了<br><br>到了大二就想着总要做点什么<br><br>于是就开始了重建之路<br><br>为了节约和方便 现在的博客是基于托管服务的<br><br>所以外观和界面都很简陋<br><br>我也在不断地完善之中<br><br>暂时就着当做是临时博客吧<br><br></font><h3 id="成长还来得及"><a href="#成长还来得及" class="headerlink" title="成长还来得及"></a>成长还来得及</h3><font size="4"><br>还记得大一上刚学<font color="#FF7F50 "><code>C++</code></font>的时候<br><br>从最一开始很吃力地写<font color="#FF7F50 "><code>Hello World</code> </font>到后来期末跟同学写小项目<br> 跨越的过程还是花了很多时间和精力的<br><br>不过也感觉到了自己的成长<br><br>可能这将是一个漫长的过程<br><br>所以希望能用博客记录我的成长和收获<br><br>我也会将自己的心得和感想随时分享…<br></font><h3 id="欢迎指正"><a href="#欢迎指正" class="headerlink" title="欢迎指正"></a>欢迎指正</h3><font size="4"><br>如果对网站或任何问题有什么意见或建议<br><br>欢迎给我留言和指正<br><br>目前的评论系统正在构建…请耐心等待…<br><br><br><br></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;欢迎来到我的个人临时博客&quot;&gt;&lt;a href=&quot;#欢迎来到我的个人临时博客&quot; class=&quot;headerlink&quot; title=&quot;欢迎来到我的个人临时博客&quot;&gt;&lt;/a&gt;欢迎来到我的个人临时博客&lt;/h2&gt;&lt;h3 id=&quot;想着总要做点什么&quot;&gt;&lt;a href=&quot;#想着总要做
      
    
    </summary>
    
      <category term="其它" scheme="http://www.simbleman.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="Hello World" scheme="http://www.simbleman.com/tags/Hello-World/"/>
    
  </entry>
  
</feed>
