[{"title":"Blog_20_Flutter中命名路由的传值","date":"2019-08-27T14:56:29.000Z","path":"2019/08/27/Blog-20-Flutter中命名路由的传值/","text":"今天的主要内容是关于Flutter的命名路由跳转，命名路由跳转主要是配置的问题 引入页面的文件首先在main函数文件中引入想要跳转的页面1import &apos;tabs/Search.dart&apos;; 在main文件中配置全局route首先要定义一个全局变量的route变量，然后再实现对页面跳转的监听（在onGenerateRoute中）其监听功能的实现是参照官网提供的实例而写成的。123456789101112131415161718192021222324252627282930313233343536class MyApp extends StatelessWidget &#123; // This widget is the root of your application. final routes=&#123; &apos;/form&apos;: (context)=&gt;FromPage(), &apos;/search&apos;:(context,&#123;arguments&#125;)=&gt;SearchPage(arguments:arguments) &#125;;//首先定义一个成员变量routes @override Widget build(BuildContext context) &#123; return MaterialApp( title: &apos;Flutter Demo1&apos;, theme: ThemeData( primarySwatch: Colors.blue, ), home: Tabs(), //在materialApp中定义onGenerateRoute实现监听 onGenerateRoute: (RouteSettings settings)&#123; final String name=settings.name; final Function pageContentBuilder = this.routes[name]; if(pageContentBuilder!=null)&#123; if(settings.arguments!=null)&#123; final Route route=MaterialPageRoute( builder: (context)=&gt; pageContentBuilder(context,arguments:settings.arguments)); return route; &#125;else&#123; final Route route =MaterialPageRoute( builder: (context)=&gt; pageContentBuilder(context)); return route; &#125; &#125; &#125; ); &#125;&#125; 在首页进行命名路由的跳转同样在这里我们实现命名路由的跳转功能，并且完成值的传递1234Navigator.pushNamed(context,&apos;/search&apos;,arguments: &#123; &quot;id&quot;:123 &#125;);//这里实现了id的传值 在search页面接收传入的值并打印首先要定义传值参数arguments之后再在构造函数中完成值的接收12345678910class SearchPage extends StatelessWidget &#123; final arguments; SearchPage(&#123;this.arguments&#125;);//这是命名路由传值中设计的arguments @override Widget build(BuildContext context) &#123; return Scaffold(appBar: AppBar(title: Text(&quot;搜索页面&quot;),), body: Text(&quot;这是一个搜索页面的内容区域$&#123;arguments !=null ? arguments[&apos;id&apos;]: &apos;0&apos;&#125;&quot;),); &#125;&#125;","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"Blog_19_杂谈（关于苹果产品）","date":"2019-08-26T15:06:06.000Z","path":"2019/08/26/Blog-19-杂谈（关于苹果产品）/","text":"今天暂停一天Flutter的介绍，主要是今天我将大部分时间都用在了苹果产品的研究上，从入手ipad，感觉我就中了苹果的毒，突然发现我之前对苹果的鄙夷是毫无道理可言的，因为苹果的生态是做的真的好，如果能配合多台苹果设备，简直就是学习和办公的神器。还有苹果的系统，比Android不知道流畅多少倍，Android手机就是各种流氓软件横行的世界。一个App恨不得它所有的权限都要，而且还是强制的，如果你不给它权限，它甚至不会给你运行，而ios上的软件就不这样了，所有的权限它都会询问你要不要授予，你是权限的唯一管理者，软件没有权利来强制你开启某一个权限，你甚至可以管理软件的核心权限，仅仅在软件开启的时候启用权限。嗯…之前对苹果的所有偏见都没有了，它贵自然有它贵的道理，但这不能成为蔑视苹果这家伟大公司的理由！","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"},{"name":"杂谈","slug":"杂谈","permalink":"http://www.simbleman.com/tags/杂谈/"}]},{"title":"Blog_18_flutter中基本路由和路由传值","date":"2019-08-25T14:50:45.000Z","path":"2019/08/25/Blog-18-flutter中基本路由和路由传值/","text":"在Flutter中所谓的路由就是指页面的跳转，Flutter中的路由分为普通路由传值和命名路由传值，这两者的使用还是有一些差异的，今天就来谈谈Flutter中的基本路由（普通路由） 通过Navigator进行普通路由跳转如果要从CommunityPage页面跳转到Search页面，首先需要在CommunityPage页面中引入Search页面，1import &apos;../Search.dart&apos;; 引入之后要在RaisedButton的OnPress(){}函数中写跳转的逻辑12345678910111213RaisedButton(child: Text(&quot;跳转到搜索页面&quot;), onPressed: ()&#123; //普通路由跳转 Navigator.of(context).push( MaterialPageRoute( builder: (context)=&gt;SearchPage() //上一句等同于 //builder:(context) //&#123; //return SearchPage(); //&#125; ) ); Flutter中基本路由的传值同样在Flutter中进行跳转传值需要进行引入Search页面,improt想要跳转的dart文件,之后再进行传值代码的编写12345678RaisedButton(child: Text(&quot;跳转到搜索页面&quot;), onPressed: ()&#123; //普通路由跳转 Navigator.of(context).push( MaterialPageRoute( builder: (context)=&gt;SearchPage(title:&apos;这是一个跳转传值的参数&apos;) ) ); 这里在SearchPage中的构造方法中来接收我们想要的数据，例如在这里我们定义SearchPage类中，需要title属性12345678910class SearchPage extends StatelessWidget &#123; String title SearchPage(&#123;this.title=&quot;表单&quot;&#125;);//这是默认值为“表单”，如果没有传值，则为默认值 @override Widget build(BuildContext context) &#123; return Scaffold(appBar: AppBar(title: Text(this.title),), body: Text(&quot;这是一个搜索页面的内容区域&quot;),); &#125;&#125; 这样在SearPage页面的最左上角就会显示“这是一个跳转传值的参数”的标题。","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"Blog_17_杂谈（可以忽略）","date":"2019-08-24T15:35:05.000Z","path":"2019/08/24/Blog-17-杂谈（可以忽略）/","text":"今天的内容是杂谈，这两天的状态很糟糕，因此我今天不打算讲有关Flutter的东西。这两天负面的情绪可能将我大脑中旺盛的精力都抽干了，所以今晚暂停flutter，明天会继续更新Flutter的","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"},{"name":"杂谈","slug":"杂谈","permalink":"http://www.simbleman.com/tags/杂谈/"}]},{"title":"Bolg_16_flutter的按钮和更改页面数据","date":"2019-08-23T13:59:49.000Z","path":"2019/08/23/Bolg-16-flutter的按钮和更改页面数据/","text":"今天的内容是关于按钮和Flutter里面StateFulWidget的使用的，像Android里面的数据操作部分的逻辑是和页面分开写的，但是Flutter却不同，数据的操作和页面部分都是在同一个文件中来完成的。 RaisedButton主要属性是两个： child:这里一般放置Button按钮里面的文字 Onpress(){}这是必须要重写的属性，主要是来设置按钮监听的动作以上两个是RaisedButton经常使用的属性和方法，可能在以后会仔细来谈谈这个组件的其他的详细用法，今日主要大致了解便可StatefulWidget今天之前所写的所有的小程序都是继承自StatelessWidget，这主要是用来存放一般的不可动的组件的，只要是不涉及数据或者是页面是静态的时候使用。主要方法：setState((){});这一般是在RaisedButton里面写，但需要更改数据的时候使用举例：1234567891011121314151617181920212223242526272829class HomePage extends StatefulWidget &#123; HomePage(&#123;Key key&#125;) : super(key: key); _HomePageState createState() =&gt; _HomePageState(); //箭头函数这里可以表示调用的意思&#125;class _HomePageState extends State&lt;HomePage&gt; &#123; int countNum = 0; @override Widget build(BuildContext context) &#123; return Column( children: &lt;Widget&gt;[ SizedBox(height: 100,), Chip( label: Text(&apos;$&#123;this.countNum&#125;&apos;), //注意这里的数据绑定写法 ), RaisedButton( child: Text(&quot;按钮&quot;), onPressed: () &#123; setState(() &#123; this.countNum++; &#125;); &#125;, ) ], ); &#125;&#125;注意数据的绑定一般是用“$&quot;符号，$&#123;数据&#125;。 总结：到现在为止，应该是能够写出稍微复杂一点是页面了，希望在接下来的几天能写出一个小程序！","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"Blog_15_关于Row，Column和AspectRatio组件","date":"2019-08-22T13:37:27.000Z","path":"2019/08/22/Blog-15-关于Row，Column和AspectRatio组件/","text":"今天的内容是关于Row,Column,AspectRatio组件,大部分应该是以例子的形式展现。因为我今天写了太多的例子了 Row和Column常用的方法： mainAxisAlignment:主轴的对齐方式 crossAxisAlignment:垂直于主轴的对齐方式 Children[]这是放置子组件的属性例子：123456789101112131415161718192021222324252627282930313233343536373839404142Widget build(BuildContext context) &#123; // TODO: implement build return Container(child: Row(//column的使用方法和Row一模一样，不过是方向相反罢了 mainAxisAlignment: MainAxisAlignment.spaceEvenly,//水平轴的分配其主轴为水平轴 crossAxisAlignment: CrossAxisAlignment.end, children: &lt;Widget&gt;[ IconContainer(Icons.home,color: Colors.red), IconContainer(Icons.search,color: Colors.blue), IconContainer(Icons.select_all,color: Colors.yellow,) ],), width: 700.0, height: 700.0,); &#125; class IconContainer extends StatelessWidget &#123; double size=32.0;//默认值 Color color=Colors.red;//这是默认值 IconData icon;//必传值 IconContainer(IconData icon,&#123;double size,Color color&#125;)&#123; this.size=size; this.icon=icon; this.color=color; &#125; @override Widget build(BuildContext context) &#123; return Container( height: 100.0, width: 100.0, color: this.color, child: Center( child: Icon( this.icon,//传入的数据 size: this.size,//这是需要传入的数据 color: Colors.white,//这也是需要传入的数据 ), ), ); &#125;&#125;注意：上面的方法是通过一个类来封装了Widget的生成，必须传入Icon值，其他的值都是可选的，这很好的利用了类的特性来完成了这个功能。 ###AspectRatio组件可以通过AspectRatio组件来设置宽度与高度的比例经常可以用来制作横着平铺的图片或者组件12345678Widget build(BuildContext context) &#123; // TODO: implement build return AspectRatio( aspectRatio: 3.0 / 1.0, //这个属性是宽度比上高度，什么也不设置的话宽度会自动填充，高度是宽度的三分之一 child: Container(color: Colors.red), ); &#125; 小结：虽然这样的组件很多，也有很多组件的功能类似，但是如果能很好合适地利用，能减少很多的代码量，实现更好的适配效果","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"Blog_14_FlutterGridView的剩余","date":"2019-08-21T14:36:46.000Z","path":"2019/08/21/Blog-14-FlutterGridView的剩余/","text":"今天的内容是关于GridView的另一种实现的方式：GridView.Builder，这种实现方式很像之前的ListView.Builder,ListView.Builder会自动循环整个list的所有数据，所以需要index（下标）和length（list的长度），这样就可以来循环整个ListView进行数据的装配了。 GridView.Builder()有几个常用且重要的属性: itemCount:这是循环数据的长度 itemBuilder:这是数据的来源,其参数是context和index，可以单独抽离出去形成一个函数来装配 gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(这是配置GridView水平或垂直表格之间的间距)一个例子12345678910111213141516171819202122232425262728293031323334353637Widget build(BuildContext context) &#123; // TODO: implement build return Container( child: GridView.builder( itemCount: listData.length, itemBuilder: this._getListData, gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 2, crossAxisSpacing: 10.0,//水平Widget之间的间距 mainAxisSpacing: 10.0),//垂直Widget之间的间距 ), padding: EdgeInsets.all(10.0),//通过Container来增加边框 ); &#125;Widget _getListData(context, index) &#123; return Container( alignment: Alignment.center, decoration: BoxDecoration( border: Border.all( color: Color.fromRGBO(233, 233, 233, 0.9), width: 2.0), //注意这里不是Colors //在Decoration里面的border属性里面添加border ), child: Column( children: &lt;Widget&gt;[ Image.network(listData[index][&quot;imageUrl&quot;]), SizedBox(height: 10.0), //这里用Container也可以，但SizedBox更合适 Text( listData[index][&quot;title&quot;], style: TextStyle(fontSize: 20.0), ) ], ), ); &#125; 说明GridView大概就这么多用法，今天其实还进行了Padding的学习，但是目前，我尽量将自己的博文时间减少这样会导致内容减少，但是我需要用更多的时间来加快我的进度，所以最近可能文章的长度大概就会这么多。","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"Blog_13_Flutter的GridView","date":"2019-08-20T15:07:53.000Z","path":"2019/08/20/Blog-13-Flutter的GridView/","text":"Flutter中的GridView给人的感觉还是挺不一样的，有一种很方便控制的感觉（相比于Android）不说了直接上代码吧！1234567891011121314151617181920212223242526List&lt;Widget&gt; _getListData() &#123; List&lt;Widget&gt; list = new List(); for (var i = 0; i &lt; 20; i++) &#123; list.add(Container( child: Text( &quot;这是第$i个数据&quot;, style: TextStyle(color: Colors.blue, fontSize: 20), ), alignment: Alignment.center, color: Colors.red, //直接在Container里面定义高度和宽度是没有意义的，没有反应，要用到childAspectRatio(宽度比高度) //height: 400.0, )); &#125; return list; &#125;GridView.count( children: _getListData(), crossAxisCount: 2, crossAxisSpacing: 20.0,//网格之间左右的间距 mainAxisSpacing: 20.0,//网格之间上下的间距 padding: EdgeInsets.all(10.0),//这是网格整体上下的外边框 childAspectRatio: 0.7,//宽度和高度的比值 ); 注：GridView有两种实现方法：1:GridView.count();2:GridView.builder();上面的代码就是一种实现方法，下面的一种方法今天暂且先不展示了。 因为今天的时间关系，没有来得及将GridView部分全部看完，所以明天可能会继续GridView，因为今天忙着去做了一些不得不做的事，所以就耽误了很长的时间，那明天继续吧！","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"Blog_11_杂谈（可以忽略）","date":"2019-08-18T14:10:09.000Z","path":"2019/08/18/Blog-11-杂谈（可以忽略）/","text":"今天是星期日，今天不谈Flutter，但我不知道今天的内容应该是什么。嗯…还是谈谈接下来的Flutter的更新的内容吧，可能最近有点焦急了，因为各方面原因，Flutter的进展很缓慢，虽然总体来讲，并没有android那样让我很困扰，但是这样的进展速度总是很让人焦虑..嗯..可能不需要我太多废话，今天就是抱怨一下最近的自己，明天开始继续Flutter！","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"},{"name":"杂谈","slug":"杂谈","permalink":"http://www.simbleman.com/tags/杂谈/"}]},{"title":"Blog_10_FlutterImage的一小部分","date":"2019-08-17T14:54:11.000Z","path":"2019/08/17/Blog-10-FlutterImage的一小部分/","text":"今天是写Blog的第十天，依旧是Flutter，依旧是Flutter的一小部分，今天的部分主要是关于Flutter的Image组件或者说是Image Widge。 Image相关image下有几个constructor其中包含了4个命名构造函数： new Image 从一个ImageProvider获取image new Image.asset 从本地文件夹获取数据 new Image.network 从网络中获取数据 new Image.file 从File中获取数据 new Image.memory 从 Uint8List中获取数据注意：后面两个并不是很常用，所以就不介绍了Image.network1image: NetworkImage(&quot;https://raw.githubusercontent.com/Haoocker/Haoocker.github.io/master/img/avatar.png&quot;),fit: BoxFit.cover) Image.asset12345child: ClipOval(child: Image.asset(&quot;images/picture.jpg&quot;, width: 200, height: 200, fit: BoxFit.cover))//注意：加载本地图片的时候记得要建立文件夹并且在文件中配置它 嗯…今天的内容就先到这里结束了，比较简短，虽然有点偷懒的写法，但是确实是没有什么好写的，当我把整体基础部分写完之后可能才会更有趣些吧！","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"Blog_09_使用Flutter的第一个页面","date":"2019-08-16T13:08:22.000Z","path":"2019/08/16/Blog-09-使用Flutter的第一个页面/","text":"终于开始将flutter的布局开始了解和学习了，经过这一天和它的接触，发现它真的比Android要好用一点，没有像Android那么多复杂的配置和不知道怎么写Java代码的困扰。flutter中的dart还是挺容易去了解和学习的。 初次开发 Flutter的开发相对android开发目前印象良好，因为它简便地多，可以不再用那个很难搞懂的android studio开发了，不过唯一使用下来感觉是前端界面如果比较复杂，真的代码就看不懂了，因为flutter的界面设计并没有像android那样可以在android studio中进行可视化设计，所以界面都是靠代码堆叠起来的，因此一旦界面复杂，那么代码的可读性真的很糟糕。今天并不打算介绍我的全部代码，因为它的可读性问题，可能我在后面有时间的时候会再来修改一下。","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"Blog_08_dart重写小程序","date":"2019-08-15T14:55:32.000Z","path":"2019/08/15/Blog-08-dart重写小程序/","text":"&emsp;&emsp;今天的文章是关于我用dart语言重写我之前的一个代码的例子，以后我也会尽量从这样的例子中来说明一个语法或者一个问题！&emsp;&emsp;不得不说dart与C++比起来好像并没有那么复杂，语法比较简单明了！ ####简单例子1首先来看在C++中的源代码。1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int i,j; for(i=0;i&lt;nums.size();i++)&#123; for(j=i+1;j&lt;nums.size();j++)&#123; if(nums[i]+nums[j]==target)&#123; return &#123;i,j&#125;; &#125; &#125; &#125; return &#123;&#125;; &#125;&#125;; 下面是我用dart重写之后的代码：123456789101112class Solution&#123; List&lt;int&gt; twoSum(List&lt;int&gt; nums,int target)&#123; //在dart中返回类型也可以不写，且方法没有加_一律都是公有方法 for(int i=0;i&lt;nums.length;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target) return [i,j]; &#125; &#125; return [];//返回一个空的List &#125;&#125; ####简单例子2这同样是C++的代码，是上面代码的改进版本1234567891011121314151617181920class Solution2 &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int,int&gt; a;//建立hash表存放数组元素 vector&lt;int&gt; b(2,-1);//存放结果 for(int i=0;i&lt;nums.size();i++) a.insert(map&lt;int,int&gt;::value_type(nums[i],i)); for(int i=0;i&lt;nums.size();i++) &#123; if(a.count(target-nums[i])&gt;0&amp;&amp;(a[target-nums[i]]!=i)) //a.count(键值)返回0或1，代表是否存在键值 &#123; b[0]=i; b[1]=a[target-nums[i]]; break; &#125; &#125; return b; &#125;;&#125;; 同样，可以用dart来改写一下1234567891011121314151617181920class Solution2&#123; twoSum(List&lt;int&gt; nums,int target)&#123; Map a=new Map(); //这里不可以用在C++中定义Map的方法：Map&lt;int&gt;&lt;int&gt; map; //因为在dart中一切都是对象，所以这样的定义方法会简单很多 //甚至可以不加new关键词 Map a=Map(); List list=new List&lt;int&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; a.addAll(&#123;nums[i]:i&#125;); //向Map中添加数据，一般用addAll函数，注意写法 &#125; for(int i=0;i&lt;nums.length;i++)&#123; if(a.containsKey(target-nums[i])&amp;&amp;a[target-nums[i]]!=i)&#123; list.add(i); list.add(a[target-nums[i]]); break; &#125; &#125; return list; &#125; 不得不说，在Dart中没有C++中那么复杂的Map定义和使用，不过也只有当很熟练掌握之后dart之后才能发挥更大的功效。 ####关于flutter这两天我在自己的电脑上完成了flutter环境的搭建以及分别在vscode中和android studio中搭建了flutter的环境。flutter的正式介绍应该是从明天开始！","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"Blog_07_关于内容的杂谈","date":"2019-08-14T15:09:25.000Z","path":"2019/08/14/Blog-07-关于内容的杂谈/","text":"其实了解下来感觉dart就是各种语言的大杂烩，你可以看见java的影子，你也可以看见JavaScript的影子，你甚至可以看见swift的影子，难怪说flutter是跨平台的呢，从这个语言的特征就能看出来了。 ###我想说的因为最近的Blog大部分都是这种知识类型的介绍，这是我学习成果的展示，也是我学习的过程。但由于在学习的过程中，我已经完成了大部分代码的编写，所以当我在写Blog的时候，设计代码的部分我会选择直接将我写好的代码拿过来复制粘贴，虽然能节省我写Blog的很多时间，可是这完全就是一种无意义的行为，因此从今天开始，我只会将我总结性的内容呈现出来，而不再是过程性的知识。 ###所以今天不再是dart相关的基础内容我思考了一下，决定今天的内容不再和dart相关，这个内容可能需要我接下来思考一下以什么样的方式呈现出来，所以今天纯粹是一种杂谈，本来打算是关于dart的剩下内容关于函数和类，我却发现其实这样的方式是有一定的问题的，因此今天暂停这样的内容呈现方式！","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"},{"name":"杂谈","slug":"杂谈","permalink":"http://www.simbleman.com/tags/杂谈/"}]},{"title":"Blog_06_Dart基础","date":"2019-08-13T13:39:02.000Z","path":"2019/08/13/Blog-06-Dart基础/","text":"今天主要是了解了dart相关的一些最基本的知识，并尝试在vscode和android studio中搭建了flutter环境，在vs code中进行flutter环境的搭配是要用到第三方的插件，但由于flutter还并没有像android那样火爆，因此并没有一个专门为他设计的ide，在android studio中也可以搭建flutter环境，也是像在vs code中需要借助第三方插件来进行开发。 dart语言基础在dart官网,可以获得到所有关于dart环境安装的必需下载。也会有关于安装步骤的说明，当然你也可以去网上搜索教程来学习。 ####dart一些常见和特殊的语法用法 main函数dart中函数的定义一般都是(){}的形式，main函数也不例外。一种定义的方法:main(){}还有一种定义的方法是:void main(){} 字符串的拼接字符串的拼接可以像c语言或者java中用”+”完成，还有一种方式是使用$特殊符号完成（类似于引用） 1234var string1=&quot;Hello,&quot;;var string2=&quot;world!&quot;;print(string1+string2);print(&quot;$string1 $string2&quot;);//加双引号 函数dart中函数的定义和C++，java中的大同小异。不过还是有特殊的定义。 123456789定义一个可选参数的函数：String printUserInfo(String username,[int age,String sex=&apos;男&apos;])&#123;//可选参数用中括号，默认参数可以在可选参数中设置if(age!=null) return &quot;姓名: $username===年龄:$age&quot;;else return &quot;姓名: $username===年龄:保密&quot;;&#125;print(printUserInfo(&quot;张三&quot;));//在这里函数的调用过程中，省去了age和sex，因为这是在函数的形参中被定义成了可选参数，sex还是一个默认参数。 4.变量因为dart的强语言特性，所以dart可以不预先定义变量类型，用var,例如：123456var name=&quot;您好dart&quot;;var num=123;//也可以通过明示来定义变量String str=&quot;hello world&quot;;print(str);//变量的名称是区分大小写的 ####dart中关于List和map相关 定义list和map都有两种定义的方法，一种是直接定义法，如List：var list=[123,12334,321321];第二种是var list=new List();list.add(123);map：第一种定义的方式：var person={ “name”:”张三”, “phone”:1234 , “work”:{ “work1”:”常州”, “work2”:”南京” }};第二种定义的方式：var p=new Map();p[“name”]=”李四”;p[“age”]=22; 增加和删除数据123456789增加数据：list: list.add(&quot;桃子&quot;);//增加一个数据 list.addAll([&quot;栗子&quot;,&quot;杏子&quot;]);//传入的是一个数组,相当于是拼接数组 map:只有一种增加数据的方法 person.addAll(&#123; &quot;work&quot;:[&apos;码农&apos;,&apos;教师&apos;]&#125;); 123456 删除数据： list:list.remove(&apos;苹果&apos;); //根据名称删除print(list);list.removeAt(1);//根据下标删除print(list); 遍历list和map的方法 1234567891:用for循环:类似于C++和java中那样的循环2:用itemfor( var item in list)&#123; print( item);&#125;3：用foreachlist.forEach((value)&#123; print(&quot;$value&quot;);&#125;); set相关 123456789set用它最主要的功能就是去除数组重复的内容var newset=new Set();newset.add(&apos;苹果&apos;);newset.add(&apos;香蕉&apos;);newset.add(&apos;苹果&apos;);print(newset);只会打印出两个数值，因为有&quot;苹果&quot;重复了print(newset.toList());将set可以轻易转换成list ####dart语言特性 强类型语言，变量的类型指定不一定要标明，因为Dart可以推断出它的类型。 在dart语言中，所有对象的类都是一个类的实例，甚至是整数，函数，null也看作对象暂且所了解的比较深刻的就是这两点，所以暂且先列出这两点","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"Blog_05:关于flutter框架的了解","date":"2019-08-12T14:54:46.000Z","path":"2019/08/12/Blog-05-关于flutter框架的了解/","text":"经过大概半天的思考，最终决定还是先从dart开始了解，再去了解futter这个谷歌的新型跨平台框架。这样看起来android都已经要过时了呢。 flutter：一个跨平台的框架相信很多人都有听说过flutter，几乎从去年的谷歌io大会之后flutter就很火。各种说法蜂拥而至，这让flutter受到了前所未有的关注。据官网介绍，国内的闲鱼平台二手商品的的详细界面就是使用flutter写成的，一套代码，就完成了在android和ios系统上运行的要求。因为他优秀的跨平台性和他流畅的运行结果，而且学习和使用这个框架也不是很难，所以我也被吸引到了解和学习他的过程中。 dart语言flutter使用dart语言，所以了解flutter，先学会dart是很有必要的。dart的很多语法和java很像，因为今天时间的原因，没有将dart详细了解，只是粗略的看了一下，同时今天也将dart的运行环境搭建完成，因为国内网络的原因，所以在一开始的下载过程中遇到了很大的影响，但是一旦下载好sdk，就能容易进行环境的搭建啦，今天就先这样草草结束，从明天开始将正式讲解dart的语法和使用！","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"Blog_04:杂谈","date":"2019-08-11T14:21:54.000Z","path":"2019/08/11/Blog-04-杂谈/","text":"&emsp;&emsp;今天是周日，因此就和自己的朋友出去聚了聚餐，聊了很多，关于很多。所以今天的学习内容没有，主要是自己的一些观点和感悟。 关于程序员和编程&emsp;&emsp;编程的这条道路对每个程序员来说是必不可少的，也是非常艰辛的，之前的一段时间一直有新闻爆料一个又一个程序员倒在了自己的工作岗位上，同时也在爆料一个又一个大型互联网公司实行996工作制度，这引起了很多程序员的不满，也引起了社会的广泛关注。&emsp;&emsp;在我看来，程序员的这个职位就是个搬砖的，纯粹是在用自己的纯劳动力换取工资，因此这不是什么大家以为的很高科技很炫酷的岗位，也不是大家看见电影里面的那种坐在电脑前面敲几行代码就能攻破美国国家国防部的防御墙。在这个岗位上你是敲着自己的代码，并且要为一个公司的利润和业绩带来提升的，如果你真的可以几行代码就能搞定一切，那么你也不会去公司找工作，你也不会来做程序员。因此程序员就是很普通的一类人，不错是用自己的脑力和体力换取工资和金钱的。&emsp;&emsp;想要成为一名程序员，门槛也不是很高，所以为什么大家都会跳槽来这个岗位，除了高工资高待遇，可能也有这一部分原因。程序员的主要工作当然是编程，因此编程很重要，从我大一接触计算机以来，也不过只学了C++,java等语言，因此我们掌握的东西还很有限，能运用的场景也不是很多，所以是要不断加强语言的掌握程度的。因此接下来的一段时间里，我可能集中叙述一些java相关和一些其他语言的。我觉得可能我会尽可能增加自己的实际例子来穿插。&emsp;&emsp;嗯..今天的杂谈到这里就先匆匆结束了。晚安，我们明天再见","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"},{"name":"杂谈","slug":"杂谈","permalink":"http://www.simbleman.com/tags/杂谈/"}]},{"title":"Blog_03:补充git的剩余部分","date":"2019-08-10T13:48:10.000Z","path":"2019/08/10/Blog-03-补充git的剩余部分/","text":"今天是台风登陆大陆的一天，也是一个周末，所以今天的内容不会太多，就是补充昨天git的剩余关于分支(branch)的部分。 git分支在这里需要了解一下git是如何保存数据的：git保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。在进行提交操作的时候，，Git会保存一个提交对象。git的分支，本质上就是指向提交对象的可变指针。 分支创建git branch testing 只会创建一个testing分支。 注意：git的默认分支名字是master，当使用git init命令的时候自动创建，同时git有一个名为HEAD的特殊指针，他是一个指向当前所在的本地分支，默认是master，所以要切换指针的的话要用到下面的命令 123git checkout testing切换到分支testing，这样HEAD会指向testinggit checkout -b testing 会创建一个分支testing并自动切换到分支上去git log --oneline --decorate --graph --all 它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。 分支合并如果当你已经完成了testing分支的工作，想要把testing分支合并到主分支中去（也就是master）可以运行git merge12git checkout master切换到master分支git merge testing 将testing分支合并到master 注意：如果在两个分支中对同一个文件的同一个部分进行了不同的修改，则会产生冲突，这时候当你merge的时，git会暂停下来等待你去解决合并产生的冲突。 分支管理git branch -v可以查看每个分支的最后一次提交 git branch -d可以删除掉当前分支（需要注意这是你已经合并之后的不需要的分支） 远程分支git ls-remote (remote) 来 显式地获得远程引用的完整列表 首先你需要知道当你clone一个仓库之后，你的本地会产生一个master分支，而服务器上的master分支在本地会变成origin/master，但你看见这个就代表是服务器上的master了。 git fetch origin会拉取服务器上的master的所有数据，更新本地的数据库。当你git fetch之后本地的master分支依旧是没有变化的，还需要加上git merge来手动合并服务器上的数据。但是当你使用了git pull便可以拉取数据并自动合并到当前所指的分支。这也是昨天所说的：git pull=git fetch+git merge.","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"Blog_02:关于git和github","date":"2019-08-09T14:33:47.000Z","path":"2019/08/09/Blog-02-关于git和github/","text":"工欲善其事必先利其器github被戏称为是世界上最大的同性社交平台，这肯定是有它自己独特的魅力。我也很早就被他的这种魅力所吸引，但是终究只是沉醉于它那富丽堂皇的表面，而迟迟没有去欣赏它真实的内涵。 git和github&emsp;&emsp;github简单来说是一个代码托管平台，你可以将自己的项目代码放到这个平台中去，这是一个公开的平台，所有人将可以看见你的项目的代码，除非你买了私人的github账号和仓库。在我的理解中这就是程序员们交流的一个平台，全世界所有的程序员在这个平台中是平等的，说全世界是因为这大概是为数不多的没有被中国所墙掉的网站，你可以在这个平台上可以展示自己的项目的代码，也可以免费看到那些优秀程序员的项目的源代码，还可以在项目中提出issue和作者交流。&emsp;&emsp;而git算是github网站的核心技术，git是什么，在廖雪峰的官方网站上他写到：“Git是目前世界上最先进的分布式版本控制系统（没有之一）。” 可以说这是对git很高很高的评价了。一开始了解git可能我们都并不是很了解为什么要这么说，但当你了解到一定程度之后你会发现，“嗯…好像真的有点厉害”。好了废话这么多就正式进入正题！ git工作的三个区域学习git首先要了解的就是git做为版本控制系统的三个最基本的区域。这也是git很多命令理解的前提和关键 git仓库我个人的理解就是最终代码和文件的存放的区域，一般是你把所有暂时不需要修改的代码和文件放在这个区域。相当于一个产品暂时最终的样子，说是暂时的因为你还可以再次修改，修改完成之后还可以覆盖掉原来的产品。 工作目录可以理解成你完成代码的编写和文件的修改等等的区域，相当于一个产品的车间，你在这里完成一切产品的加工和创造 暂存区域顾名思义。这里的文件和代码是在工作目录完成之后暂存的，准备提交到git仓库的区域。相当于一个产品的中转站，在车间完成之后从这里转存到最终的目的地。 git的常用命令我们一般用git bash来完成git的所有工作。因此命令的掌握是非常重要的。 git clone https://… projectname可以从github中克隆一个仓库 git status 查看git的三个区域中的文件的状态。 git status -s 简化版本：例：M READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。 git add相当于文件已经被跟踪并储存到暂存区 git diff 用来查看尚未暂存的文件更新了哪些部分git diff –cached或者git diff –staged查看已经暂存起来的变化 git commit将暂存区域中的文件提交到git仓库中可以使用git commit -m ‘将本次的提交信息可以写在这里’git commit -a可以跳过git add（已跟踪文件） git rm 连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清 单中了。git rm -f强制删除文件，针对还没有commit的文件 git mv filename1 filename2可以给文件改名字 git log 有很多的参数选择 撤销：有时候提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行$ git commit –amend“git reset HEAD filename撤销将一个文件放入暂存区（移出暂存区）git checkout – filename撤消对文件的修改 git remote，如果是克隆的会显示origingit remote -v 会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。 关于分支branch&emsp;&emsp;首先要区别git fetch 和git pull的区别，这两个的区别显得很重要，要必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。而运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支，一般当前的分支就是master。简单理解：git pull=git fetch+git merge.&emsp;&emsp;关于分支的设计可以说是git显得很强大的一个重要原因，因为篇幅和时间的原因，我准备下次再来好好谈谈。","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"Blog_01:关于Markdown语法","date":"2019-08-08T12:00:00.000Z","path":"2019/08/08/Blog-01-关于Markdown语法/","text":"工欲善其事必先利其器 1.使用Markdown语法的原因&emsp;&emsp;从我开始写blog的第一天就学习了这个Markdown的语法，要说使用它的原因，我现在还真的说不出到底为什么，不过用markdown语法写一段时间文章，相信我你会喜欢上它的。在Markdown设计之初就是致力于是阅读和创作文档变得更容易，在使用的过程中的确有一种效率更高的感觉，因为你再也不需要用鼠标和按钮进行排版了。 2.Markdown语法&emsp;&emsp;最基本的用法在这里我就不具体介绍了，当你在搜索引擎搜索之后会发现教程实在是很多。甚至有教程在宣扬5分钟之内就可以学会，的确学习之后发现Markdown相比于html语法还是比较简单的。但是今天当我重新了解了一遍Markdown之后，我发现有几个语法一直没有注意到,所以就着重记录几个。 是关于有序列表数字的问题&emsp;&emsp;有序列表是通过数字加半角的句号完成的，如”1.”表示第一个。但是在使用的过程中发现数字是可以无序的，也就是说当你1.以后后一行应该用2.但是你用了3.或者任何一个数字显示出来依旧是2.可以看一下接下来的两个例子1231. 这是第一行 6. 这是第二行 7. 这是第三行 显示出来： 这是第一行 这是第二行 这是第三行 所以下次只要注意列表的第一个数字就足够了 关于转义字符的问题&emsp;&emsp;首先说明在Markdown中转义字符是“\\”（反斜杠）它可以完成特殊字符的一般化比如\\这里的字体没有受到\\的影响\\*，如果去掉两个转义字符就变成了：这里的字体没有受到\\的影响*，显然已经受到了影响（变成粗体了）。 关于内联元素的链接问题&emsp;&emsp;首先看这一段话：“你可以在百度上进行搜索，也可以在谷歌上进行搜索我的blog”以下是上面那句话的源代码1234“你可以在[百度][]上进行搜索，也可以在[谷歌][]上进行搜索我的blog”[百度]: https://www.baidu.com/ &quot;点击百度一下！&quot;[谷歌]: https://www.google.com/ &quot;点击进行谷歌搜索&quot; 还有第二种实现方法贴上源代码1234“你可以在[百度][1]上进行搜索，也可以在[谷歌][2]上进行搜索我的blog”[1]: https://www.baidu.com/ &quot;点击百度一下！&quot;[2]: https://www.google.com/ &quot;点击进行谷歌搜索&quot; 以上的效果是一样的但是原理不同，第二种个人感觉有点类似html中的id属性的实现方法。","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"主题更换以及一些说明","date":"2019-08-07T11:42:55.000Z","path":"2019/08/07/主题更换以及一些说明/","text":"一：主题更换1：前情概要 &emsp;&emsp;距离我上一次更新已经过去很久了，从上一次更新到现在发生了很多事情，曾一度想关闭这个博客想重新开一个自己的网站，但是想到目前自己真的没有很大的需求去开一个网站，想开网站无非是折腾自己，有点大材小用的意思，所以我还是回到了这个blog。 &emsp;&emsp;4月份和5月份大概是我自己瞎忙的时候，我也不知道自己在忙什么，所以从那个时候开始就想着有时间来整一整，然后才发现真的不要相信自己对自己说的谎话，以后可能是无限期。就这样从六月份开始我应该在忙着准备期末考试了，（嗯..期末就不想提了，太心痛！）那一备考阶段感觉是我上半年最迷茫的时候…所以就这样到7月中旬期末考试结束后我就回家了。接着就是半个月去福建福州和厦门的旅行，可以说是一次身心的放松吧。（虽然被晒得黑了两度！）可以看到页面最上面的背景照片就是我这次在厦门的一个沙滩所拍摄的！在这次更新中我觉得好看就放了上去，接下来谈谈这次的主题更新！ 2:主题更换 &emsp;&emsp;之前的主题一直用的是next主题，虽然网上的教程很多，但是无论什么样式看来看去真的很丑，所以最近几天就下决心换了一个主题，目前的样式就是所更换之后的主题，是一个中国程序员所编写的BlueLake主题，整个过程他在自己的github主题中写的很详细了，配置也不算太麻烦，感觉比之前的next主题好配置，（也可能我是更熟悉应用了）。所以整个过程没有之前费脑。目前我加上去的最好的功能感觉就是gittalk评论了，但是需要你登录自己的github账号，然后才能评论。我大部分配置的时间是花在了自定义blog的风格上面，这个主题和手机的适配真的也很好，这里就不具体讲这个blog的构造了，可以随处逛逛来自己理解！ 3：日后再要加上的功能 &emsp;&emsp;目前计划加上的功能有: 1:微信支付宝的打赏功能 2:被百度搜索引擎收录,并能查询到我的blog(目前已经被谷歌收录) 二：一些说明1：博客给谁看？&emsp;&emsp;在我写完这篇blog之前，我几乎没有公开过，甚至于我的舍友看了我的github才知道我写blog。原因首先是因为我的文章数目不够，当别人进来看的时候会不明白我的博客是用来做什么的，其次，我觉得我也没做好准备，目前了解和掌握的“技能点”很少，怕坚持不了第二点说明就自己投降了，没错重点是第二点说明： 2：每天写blog！&emsp;&emsp;嗯，从今天开始，也就是中国的情人节七夕，以后每天写一篇blog，一直到我写得不想写为止！我将受到所有人的共同监督！&emsp;&emsp;今天的blog算是一个继往开来的第零篇，摆脱过去，重新开始！","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"非常艰难的填坑之路","date":"2019-03-31T08:28:45.000Z","path":"2019/03/31/非常艰难的填坑之路/","text":"除了吃饭睡觉，这一天都在填一个其实只要用3行代码解决的坑，这中间伴随着郁闷和无尽的郁闷，甚至到达了怀疑自我的境界。。不过还好就在刚刚成功解决了。现在怀着非常激动的心情来叙说这个艰难的过程的结果。 缘由这个坑是有关JSON数据处理的，本来一点不了解这个数据格式的，上次在做微信小程序的时候偶然了解到了它，在做这个数据处理前，我以为会很简单。可是正是因为我的忽视，一开始浪费了很多时间在做无谓的工作。 关于json的微信小程序处理因为要选择一个客户端测试，所以就借用了微信小程序，要在java服务器中处理微信wx.request中的json数据，在微信小程序的js里面一定要先处理,不然等到它把数据发送到服务器端，会发现输出的一直是[object][object]一直看不到具体的对象的值，这时候叫天不应叫地不灵，无论在服务端怎么处理，都会发现是无用功，超级郁闷。123456789101112131415具体处理方法：json.stringify()方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串json.parse() 方法将数据转换为 JavaScript 对象( 将字符串转成json对象。 )js中的数据data: [&#123; &quot;coorx&quot;: 12, &quot;coory&quot;: 13 &#125;, &#123; &quot;coorx&quot;: 123, &quot;coory&quot;: 133 &#125;, &#123; &quot;coorx&quot;: 123, &quot;coory&quot;: 133 &#125; ]var arrJosn = JSON.stringify(this.data.data);传输的数据：data: &#123; &quot;data&quot;: arrJosn &#125;,只有这样data传到服务端才能正常显示，真坑啊。 服务端的处理在服务端发现是小程序中的json未处理前，在服务端我几乎把所有json处理的方式都试了一遍，但是没有效果。。但是试完了之后发现自己对json这个数据类型处理的思路也很清晰了。我用的是阿里巴巴的fastjson库。不过仔细想想我还是没有明白那个困惑我很久的情况：1234567891011121314151617181920212223 private static final String JSON_ARRAY_STR = &quot;[&#123;\\&quot;coory\\&quot;:13,\\&quot;coorx\\&quot;:12&#125;,&#123;\\&quot;coory\\&quot;:13,\\&quot;coorx\\&quot;:12&#125;,&#123;\\&quot;coory\\&quot;:13,\\&quot;coorx\\&quot;:12&#125;]&quot;; public static void main(String[] args)&#123; JSONArray jsonArray = JSON.parseArray(JSON_ARRAY_STR); System.out.println(jsonArray);&#125;以上代码运行一点问题都没有但是如果将JSON_ARRAY_STR变成另一种方法得到的，输出就会一直报错。 JSONArray jsonArray = new JSONArray(); for (int i = 0; i &lt; 3; i++) &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;coorx&quot;, 12); jsonObject.put(&quot;coory&quot;, 13); jsonArray.add(jsonObject); &#125; String str=jsonArray.toJSONString(); String JSON_ARRAY_STR=JSON.toJSONString(str); JSONArray jsa=JSON.parseArray(JSON_ARRAY_STR); 执行到最后一句一直报Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: syntax error, expect [, actual string, pos 0, fieldName null 但是你输出str2跟上面一种方法的JSON_ARRAY_STR一模一样。 无解啊 最后成功解决的原因就是不用把微信小程序处理过的数据再toJSONString。123String coor=request.getParameter(&quot;data&quot;);JSONArray jsa=JSONArray.parseArray(coor);这里直接parseArray于是就成功了转换成了json数组了。 总结这个坑的主要问题就是上面这些，虽然有些时候很多坑填填是必要的，但是这次的填坑之旅花费了大量的时间，而且非常艰难，这是我对这个问题的简单化造成的，一开始并没有想很系统的去了解和解决这个问题，总是想着网上copy其他人的代码节省时间，现在才发现自己去了解其中的原因和道理才是真正省时间的方法。嗯..还有很多问题等着去解决呢，还是不废话了。","tags":[{"name":"json","slug":"json","permalink":"http://www.simbleman.com/tags/json/"}]},{"title":"队列的实现","date":"2019-03-26T05:47:43.000Z","path":"2019/03/26/队列的实现/","text":"队列也是一种特殊的线性表，它的特点是先进先出，所有的插入操作都在表的一端进行，而删除操作都在表的另一端进行， 队列的指针实现因为队列要在线性表的两段进行操作，为了方便使用，就不能像栈那样只有个节点型就好了，因此它的定义和栈会有不同。 队列的定义和初始化1234567891011121314151617队列的节点定义struct node&#123; node *next; int element;&#125;;队列的定义struct QUEUE&#123; node * front;//表头节点 node * rear;//指向最后一个元素的节点&#125;;初始化void init(QUEUE &amp;q)&#123;//初始化为空表，头指针和尾指针重合 q.front=new node; q.front-&gt;next=NULL; q.rear=q.front; cout&lt;&lt;&quot;初始化成功&quot;&lt;&lt;endl;&#125; 插入操作（在队列的尾部进行）1234567void enqueue(int x,QUEUE &amp;q)&#123; q.rear-&gt;next=new node; q.rear=q.rear-&gt;next; q.rear-&gt;next=NULL; q.rear-&gt;element=x; cout&lt;&lt;&quot;插入队列成功&quot;&lt;&lt;endl;&#125; 删除操作（在队列的头部进行）1234567891011void dequeue(QUEUE &amp;q)&#123; node * temp; if(q.rear==q.front)&#123; cout&lt;&lt;&quot;错误，该队列为空！&quot;&lt;&lt;endl; &#125; else&#123; temp=q.front-&gt;next; q.front-&gt;next=temp-&gt;next; delete temp; &#125;&#125; 队列的数组实现（循环数组）因为队列的特殊性，一般的数组难以满足完美地满足它的要求，所以这里用循环数组来实现它。 队列的定义和初始化12345678910typedef struct&#123; int front; int rear; int elements[maxlength];&#125;QUEUE; void init(QUEUE &amp;Q)&#123;//将队列置为空 Q.front=0; Q.rear=maxlength-1;&#125; 注：为了防止循环队列队满和队空的状态相同，因此这里将rear比front滞后一个位置做为队空的状态，front为0，rear为maxlength-1，而把rear所指单元比front滞后两个位置做为队满的状态。 循环数组很重要的addone函数1234addone函数算是实现了循环数组循环的条件int addone(int i)&#123; return ((i+1)%maxlength);&#125; 插入操作（将rear往前移动一个位置（顺时针））1234567891011void insert(QUEUE &amp;Q,int x)&#123; if(addone(addone(Q.rear))==Q.front)&#123; cout&lt;&lt;&quot;错误，该队列已满！&quot;&lt;&lt;endl; &#125; else &#123; Q.rear=addone(Q.rear); Q.elements[Q.rear]=x; cout&lt;&lt;x&lt;&lt;&quot;插入队列成功！&quot;&lt;&lt;endl; &#125;&#125; 删除操作(将front往前移动一个位置（顺时针）)12345678void deleteq(QUEUE &amp;q)&#123; if(addone(q.rear)==q.front)&#123; cout&lt;&lt;&quot;错误，该附列已空&quot;&lt;&lt;endl; &#125; else&#123; q.front=addone(q.front); &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.simbleman.com/tags/数据结构/"},{"name":"队列","slug":"队列","permalink":"http://www.simbleman.com/tags/队列/"}]},{"title":"栈的实现","date":"2019-03-25T13:31:20.000Z","path":"2019/03/25/栈的实现/","text":"栈和队列都是一种特殊的线性表，因此都可以用指针和数组来实现它。在这里只实现他的一些关键的操作函数和方法。 栈的数组实现栈的数据逻辑特点是先进后出，所以一般用数组的最后位置当做栈的底部，而把数组开头的元素当做栈的顶部，因此入栈也称作压栈，且数据的删除和插入操作都只在栈的一端进行，因此栈的数据结构有int型的top，指向栈顶元素，还有一个数组用于存放栈的元素。 1：栈的数组结构体定义和初始化12345678910const int maxsize=100;struct STACK&#123; int top; int elements[maxsize];&#125;;void init(STACK &amp;s)&#123; s.top=maxsize;//当top为maxsize时，则栈为空 &#125; 2:push操作12345678910void push(STACK &amp;s,int x)&#123; if(s.top==0)&#123; cout&lt;&lt;&quot;错误，该栈已满&quot;&lt;&lt;endl; &#125; else&#123; s.top-=1; s.elements[s.top]=x; cout&lt;&lt;x&lt;&lt;&quot;压栈成功&quot;&lt;&lt;endl; &#125;&#125; 3:pop操作123456789void pop(STACK &amp;s)&#123; if(s.top==maxsize)&#123; cout&lt;&lt;&quot;错误，该栈为空&quot;&lt;&lt;endl; &#125; else&#123; s.top+=1; cout&lt;&lt;&quot;出栈成功，已删除栈顶元素&quot;&lt;&lt;endl; &#125;&#125; 注：其他操作功能可以根据需要进行设计 栈的指针实现栈的指针实现同数组实现，他的数据的插入和删除操作都在表头进行，和数组实现相比没有栈满的情况出现。 1:结构体定义及初始化1234567891011struct node&#123; node * next; int element;&#125;;typedef node * STACK;void init(STACK &amp;S)&#123;//初始化即将栈置空 S=new node; S-&gt;next=NULL; cout&lt;&lt;&quot;初始化成功！&quot;&lt;&lt;endl; &#125; 2:push操作12345678void push(STACK &amp;s,int x)&#123; STACK stk; stk=new node; stk-&gt;element=x; stk-&gt;next=s-&gt;next; s-&gt;next=stk; cout&lt;&lt;x&lt;&lt;&quot;入栈成功&quot;&lt;&lt;endl;&#125; 3:pop操作12345678910111213void pop(STACK &amp;s)&#123; STACK stk; cout&lt;&lt;s-&gt;next-&gt;element&lt;&lt;&quot;出栈成功！&quot;&lt;&lt;endl; if(s-&gt;next!=NULL)&#123; stk=s-&gt;next; s-&gt;next=stk-&gt;next; delete stk; &#125; else&#123; cout&lt;&lt;&quot;错误，该栈为空&quot;&lt;&lt;endl; &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.simbleman.com/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"http://www.simbleman.com/tags/栈/"}]},{"title":"线性表的实现","date":"2019-03-18T11:52:53.000Z","path":"2019/03/18/线性表的实现/","text":"最近在学习“数据结构和算法”这门课，刚学到了线性表这边，于是自己就课后用C++写了一下，但并没有用类的方式写它，单纯的用C的语言完成的，但写完后才发现跟自己在课上理解的所谓的线性表完全不一样。。 分类线性表的实现可以分为数组的实现和指针的实现，也称作顺序表和链表。这两种方法各有各的优缺点，但在这里要区分一下概念，一般我们所说的线性表是逻辑结构，顺序表和链表是存储结构。 数组实现本来想讲一讲struct的使用方法的，不过感觉有点偏离主题了，这里可以给出struct参考文章，其实只要了解和学习C++中的使用方法就基本可以了,如果有需要再去了解C语言中的用法。 1：结构体定义和初始化123456789101112#define maxlength 100struct list&#123; int elements[maxlength];//这里的int可以换成任何其他的数据类型 int last;//这是用以指示表中的最后一个元素在数组中的位置&#125;注意：数组实现方法中数组的开头不放元素，即elements[0]为空初始化：void init(list &amp;l)&#123; l.last=0;&#125;定义position：typedef int position; 2:插入和删除元素123456789101112131415161718192021222324252627void insertL(list &amp;l,position p,int x)//用形参引用可以改变实参的值 &#123; if(l.last&gt;=maxlength-1) cout&lt;&lt;&quot;Error! The list is full!&quot;; else if(p&gt;l.last+1||p&lt;=0) cout&lt;&lt;&quot;Error! The position does not exist!&quot;; else&#123; int i; for(i=l.last;i&gt;=p;i--)&#123; l.elements[i+1]=l.elements[i]; &#125; l.last+=1; l.elements[p]=x; &#125; &#125;void deleteL(list &amp;l,position p)&#123; int i; if(p&gt;l.last+1||p&lt;=0) cout&lt;&lt;&quot;Error! The position does not exist!&quot;; else&#123; for(i=p;i&lt;=l.last-1;i++)&#123; l.elements[i]=l.elements[i+1]; &#125; l.last-=1; &#125; 3：元素的查找1234567891011121314151617按值查找：int locateN(list &amp;l,int x)&#123; position q; for(q=1;q&lt;=l.last;q++)&#123; if(l.elements[q]==x)&#123; return q; &#125; &#125; return -1;//如果不存在就返回一个非正常数字&#125; 按位查找：int locateP(list &amp;l,int x)&#123; if(x&lt;1||x&gt;l.last) cout&lt;&lt;&quot;不存在这个位置的数据&quot;&lt;&lt;endl; else return l.elements[x]; &#125; 注：其他功能可以根据需要自己实现，这里就不一一实现了 指针实现线性表的指针实现主要是靠一个一个节点连接起来的，所以了解节点的概念很重要，还有一些C语言中用到的或者已经遗忘的知识点，这里简单回忆下new的用法，new是在C++中使用的动态内存分配，一般是给指针分配内存。底层调用malloc，返回的是void*指针类型。 1:结构体定义123456 struct node&#123; node * next; int element;&#125;;typedef node * LIST;typedef node * position; 2:初始化1234567void init(LIST &amp;l)&#123;//参数必须要为引用或者为一个指针 若为指针时，则传过来的实参要为地址 l=new node; //l=(LIST)malloc(sizeof(node));//malloc返回的是一个指针，等于从内存中获取空间 l-&gt;next=NULL; l-&gt;element=2;&#125;注：这里用new和malloc都可以的 3:插入和删除元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253bool insert(int x,int p,LIST &amp;l)&#123; int i; LIST L=l; LIST s; for(i=1;i&lt;p;i++)&#123; L=L-&gt;next; if(L==NULL) return false; &#125; s=(LIST)malloc(sizeof(node)); s-&gt;next=L-&gt;next; L-&gt;next=s; s-&gt;element=x; return true;&#125;注：p是指的第几个位置，其实时间复杂度只有O(1);分开写：void insertl(int x,position p)&#123;//实际的插入函数，复杂度只有O(1) position s; s=(LIST)malloc(sizeof(node)); s-&gt;next=p-&gt;next; p-&gt;next=s; s-&gt;element=x; cout&lt;&lt;&quot;插入成功！&quot;&lt;&lt;endl;&#125;bool insert(int x,int p,LIST &amp;l)&#123;//用来寻找position p int i; LIST L=l; for(i=1;i&lt;p;i++)&#123; L=L-&gt;next; if(L==NULL) return false; &#125; insertl(x,L); return true; &#125;bool deletel(int p,LIST &amp;l)&#123;//跟insert道理类似 int i; LIST L=l; LIST temp; for(i=1;i&lt;p;i++)&#123; L=L-&gt;next; if(L==NULL) return false; &#125; temp=L-&gt;next; L-&gt;next=temp-&gt;next; delete temp; return true;&#125; 4:查找元素123456789101112position locate(int x,LIST &amp;L)&#123; position p; p=L; while(p-&gt;next!=NULL)&#123; if(p-&gt;next-&gt;element==x)&#123; return p; //返回的是要查找元素的前一个位置 &#125; else p=p-&gt;next; &#125; return p;&#125; 总结顺序存储特点：长度固定，不易扩充，插入删除费时间O(n)，估算长度，浪费空间链式存储特点：长度灵活可变，易扩充，访问元素费时间O(n)，实际长度，节省空间。数组实现的方式中逻辑结构和物理结构相同，是连续的存储空间，而指针时不连续的存储空间。目前看来其实简单的线性表还是用数组实现更好，因为指针实现的insert和delete还要去找它的position，目前在我看来依旧很费时间。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.simbleman.com/tags/数据结构/"},{"name":"线性表","slug":"线性表","permalink":"http://www.simbleman.com/tags/线性表/"}]},{"title":"好久没更新了","date":"2019-03-12T13:11:31.000Z","path":"2019/03/12/好久没更新了/","text":"已经快有一个月没有更新了，有点惭愧。 主要是从准备开学到正式开学，一直都在做一个关于微信小程序的小项目，以前完全没有这方面的学习经历和经验，所以就从web的前端和后端一直看到了微信小程序。这其中总感觉时间不够用，所以一直很赶时间，就没有来更新博客了，但事实也证明了时间是不够用的。虽然这个小项目可能不会很完美结束，但这一个月还是学到了不少的。接下来我会尽量缩短我更新博客的时间，将这个月的经历一一分享。","tags":[]},{"title":"Linux的正则表达式基础","date":"2019-02-17T07:24:45.000Z","path":"2019/02/17/Linux的正则表达式基础/","text":"前言:在认识和学习bash的过程中，其中的通配符和让我印象深刻，当我了解到正则表达式时，它的功能同样让我感到惊讶，他们的相似之处有很多很多，因此经常会混淆他们的用法，但是这两者是完全不一样的东西！根据我的理解，通配符就像是bash中的特殊符号，可以直接被bash识别，最常用的用法是配合ls命令，进行查询操作的功能。而正则表达式则是一种字符串处理的表示方法，有很强大的字符串处理能力，可以信息进行加工和处理从而呈现出自己想要的信息。因为目前最经常用到的字符串选取工具程序是grep，所以就先用grep介绍最基本的正则表达式。 正文：先给出grep常用的语法参数：123456-c:&quot;查找字符串&quot;的次数-i: 忽略大小写的不同-n: 输出行号-v: 反向选择-A: (after)后面可加数字n，表示将后面的n行列出来-B: (before)前面可加数字n,表示将前面的n行列出来假设目标文件为text.txt1：查找特定字符串 grep -in &#39;the&#39; text.txt 查找文件中包含大小写the的字符串的所有行，并打印行号 grep -vn &#39;the&#39; text.txt 查找文件中不含the的字符串的所有行 2：利用中括号查找字符集合 grep -n &#39;t[ae]st&#39; text.txt 查找文件中包含tast或者test的字符串的所有行 grep -nA3 &#39;[^g]00&#39; text.txt 查找文件中包含oo字符串且前面没有字母g的的所有行，并且还输出符合条件行的后面三行。 grep -n &#39;[^a-z]oo&#39; text.txt 查找包含oo字符串，并且oo之前没有小写字母 注：小写字母还可以用[:lower:]表示，即[^a-z]等同于[^[:lower:]]不过初入门可以不用记忆太多，暂且先不列出这种特殊符号。 3:任意一个字符”.” grep -n &#39;g..d&#39; text.txt 选取含有g??d的字符串，即共有4个字符的所有行 4：重复字符”*” grep -n &#39;roo*t&#39; text.txt 选取含有以r开头t结尾且中间必定含有一个o的字符串，’ro*t’表示r和t中间可以含有零到无穷个o 注：如果想得到g开头和g结尾的字符串，我们经常会写成grep -n &#39;g*g&#39; text.txt而这个表示选取含有字母g的那一行，因为 g* 表示是空字符或者含有一个即以上的g。要想得到符合要求的字符串要写成grep -n &#39;g.*&#39;g text.txt 因为”.”表示的是任意一个字符,所以 .* 表示零个或任意一个字符的意思。 5：行首和行尾字符 grep -n &#39;^the&#39; text.txt 查找行首有the的所有行 grep -n &#39;^[a-z]&#39; text.txt 查找行首是小写字母的所有行 grep -n &#39;^[^a-zA-Z]&#39; text.txt 查找行首不是英文字母的所有行 这里注意^在[]里面和外面的不同含义哦！ 注：Linux里面的断行符是”$”,而windows中的断行符为”^M$”,所以行尾的标识符为$ grep -n &#39;\\.$&#39; text.txt 选取文本中以”.”（英文句号）结尾的所有行，这里的\\是转义字符，”\\.”表示解除”.”的特殊含义 grep -n &#39;^$&#39; text.txt 表示选取所有的空白行 综上所述，基础正则表达式字符： 字符 意义 ^word 要查找的字符串在行首 word$ 要查找的字符串在行尾 .(小数点) 代表一定有一个任意字符的字符 \\ 转义字符 * 重复前一个字符零次或者无数次 [] 从[]集合里面选出一个想要的字符 [n1-n2] 从n1到n2中选取一个想要的字符 [^] 从集合里面找出不要的字符串","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.simbleman.com/tags/Linux/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.simbleman.com/tags/正则表达式/"}]},{"title":"Hello World","date":"2019-02-15T16:22:17.208Z","path":"2019/02/16/hello-world/","text":"欢迎来到我的个人临时博客想着总要做点什么大一也像模像样的在阿里云上搞了一个传统的网站博客不过那只是出于好奇和尝试 那时什么也不懂什么也不会最后费时费力还费钱就没有继续搞下去了到了大二就想着总要做点什么于是就开始了重建之路为了节约和方便 现在的博客是基于托管服务的所以外观和界面都很简陋我也在不断地完善之中暂时就着当做是临时博客吧 成长还来得及还记得大一上刚学C++的时候从最一开始很吃力地写Hello World 到后来期末跟同学写小项目 跨越的过程还是花了很多时间和精力的不过也感觉到了自己的成长可能这将是一个漫长的过程所以希望能用博客记录我的成长和收获我也会将自己的心得和感想随时分享… 欢迎指正如果对网站或任何问题有什么意见或建议欢迎给我留言和指正目前的评论系统正在构建…请耐心等待…","tags":[{"name":"Hello World","slug":"Hello-World","permalink":"http://www.simbleman.com/tags/Hello-World/"}]}]