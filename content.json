[{"title":"Blog_02:关于git和github","date":"2019-08-09T14:33:47.000Z","path":"2019/08/09/Blog-02-关于git和github/","text":"工欲善其事必先利其器github被戏称为是世界上最大的同性社交平台，这肯定是有它自己独特的魅力。我也很早就被他的这种魅力所吸引，但是终究只是沉醉于它那富丽堂皇的表面，而迟迟没有去欣赏它真实的内涵。 git和github&emsp;&emsp;github简单来说是一个代码托管平台，你可以将自己的项目代码放到这个平台中去，这是一个公开的平台，所有人将可以看见你的项目的代码，除非你买了私人的github账号和仓库。在我的理解中这就是程序员们交流的一个平台，全世界所有的程序员在这个平台中是平等的，说全世界是因为这大概是为数不多的没有被中国所墙掉的网站，你可以在这个平台上可以展示自己的项目的代码，也可以免费看到那些优秀程序员的项目的源代码，还可以在项目中提出issue和作者交流。&emsp;&emsp;而git算是github网站的核心技术，git是什么，在廖雪峰的官方网站上他写到：“Git是目前世界上最先进的分布式版本控制系统（没有之一）。” 可以说这是对git很高很高的评价了。一开始了解git可能我们都并不是很了解为什么要这么说，但当你了解到一定程度之后你会发现，“嗯…好像真的有点厉害”。好了废话这么多就正式进入正题！ git工作的三个区域学习git首先要了解的就是git做为版本控制系统的三个最基本的区域。这也是git很多命令理解的前提和关键 git仓库我个人的理解就是最终代码和文件的存放的区域，一般是你把所有暂时不需要修改的代码和文件放在这个区域。相当于一个产品暂时最终的样子，说是暂时的因为你还可以再次修改，修改完成之后还可以覆盖掉原来的产品。 工作目录可以理解成你完成代码的编写和文件的修改等等的区域，相当于一个产品的车间，你在这里完成一切产品的加工和创造 暂存区域顾名思义。这里的文件和代码是在工作目录完成之后暂存的，准备提交到git仓库的区域。相当于一个产品的中转站，在车间完成之后从这里转存到最终的目的地。 git的常用命令我们一般用git bash来完成git的所有工作。因此命令的掌握是非常重要的。 git clone https://… projectname可以从github中克隆一个仓库 git status 查看git的三个区域中的文件的状态。 git status -s 简化版本：例：M READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。 git add相当于文件已经被跟踪并储存到暂存区 git diff 用来查看尚未暂存的文件更新了哪些部分git diff –cached或者git diff –staged查看已经暂存起来的变化 git commit将暂存区域中的文件提交到git仓库中可以使用git commit -m ‘将本次的提交信息可以写在这里’git commit -a可以跳过git add（已跟踪文件） git rm 连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清 单中了。git rm -f强制删除文件，针对还没有commit的文件 git mv filename1 filename2可以给文件改名字 git log 有很多的参数选择 撤销：有时候提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行$ git commit –amend“git reset HEAD filename撤销将一个文件放入暂存区（移出暂存区）git checkout – filename撤消对文件的修改 git remote，如果是克隆的会显示origingit remote -v 会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。 关于分支branch&emsp;&emsp;首先要区别git fetch 和git pull的区别，这两个的区别显得很重要，要必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。而运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支，一般当前的分支就是master。简单理解：git pull=git fetch+git merge.&emsp;&emsp;关于分支的设计可以说是git显得很强大的一个重要原因，因为篇幅和时间的原因，我准备下次再来好好谈谈。","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"Blog_01:关于Markdown语法","date":"2019-08-08T12:00:00.000Z","path":"2019/08/08/Blog-01-关于Markdown语法/","text":"工欲善其事必先利其器 1.使用Markdown语法的原因&emsp;&emsp;从我开始写blog的第一天就学习了这个Markdown的语法，要说使用它的原因，我现在还真的说不出到底为什么，不过用markdown语法写一段时间文章，相信我你会喜欢上它的。在Markdown设计之初就是致力于是阅读和创作文档变得更容易，在使用的过程中的确有一种效率更高的感觉，因为你再也不需要用鼠标和按钮进行排版了。 2.Markdown语法&emsp;&emsp;最基本的用法在这里我就不具体介绍了，当你在搜索引擎搜索之后会发现教程实在是很多。甚至有教程在宣扬5分钟之内就可以学会，的确学习之后发现Markdown相比于html语法还是比较简单的。但是今天当我重新了解了一遍Markdown之后，我发现有几个语法一直没有注意到,所以就着重记录几个。 是关于有序列表数字的问题&emsp;&emsp;有序列表是通过数字加半角的句号完成的，如”1.”表示第一个。但是在使用的过程中发现数字是可以无序的，也就是说当你1.以后后一行应该用2.但是你用了3.或者任何一个数字显示出来依旧是2.可以看一下接下来的两个例子1231. 这是第一行 6. 这是第二行 7. 这是第三行 显示出来： 这是第一行 这是第二行 这是第三行 所以下次只要注意列表的第一个数字就足够了 关于转义字符的问题&emsp;&emsp;首先说明在Markdown中转义字符是“\\”（反斜杠）它可以完成特殊字符的一般化比如\\这里的字体没有受到\\的影响\\*，如果去掉两个转义字符就变成了：这里的字体没有受到\\的影响*，显然已经受到了影响（变成粗体了）。 关于内联元素的链接问题&emsp;&emsp;首先看这一段话：“你可以在百度上进行搜索，也可以在谷歌上进行搜索我的blog”以下是上面那句话的源代码1234“你可以在[百度][]上进行搜索，也可以在[谷歌][]上进行搜索我的blog”[百度]: https://www.baidu.com/ &quot;点击百度一下！&quot;[谷歌]: https://www.google.com/ &quot;点击进行谷歌搜索&quot; 还有第二种实现方法贴上源代码1234“你可以在[百度][1]上进行搜索，也可以在[谷歌][2]上进行搜索我的blog”[1]: https://www.baidu.com/ &quot;点击百度一下！&quot;[2]: https://www.google.com/ &quot;点击进行谷歌搜索&quot; 以上的效果是一样的但是原理不同，第二种个人感觉有点类似html中的id属性的实现方法。","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"主题更换以及一些说明","date":"2019-08-07T11:42:55.000Z","path":"2019/08/07/主题更换以及一些说明/","text":"一：主题更换1：前情概要 &emsp;&emsp;距离我上一次更新已经过去很久了，从上一次更新到现在发生了很多事情，曾一度想关闭这个博客想重新开一个自己的网站，但是想到目前自己真的没有很大的需求去开一个网站，想开网站无非是折腾自己，有点大材小用的意思，所以我还是回到了这个blog。 &emsp;&emsp;4月份和5月份大概是我自己瞎忙的时候，我也不知道自己在忙什么，所以从那个时候开始就想着有时间来整一整，然后才发现真的不要相信自己对自己说的谎话，以后可能是无限期。就这样从六月份开始我应该在忙着准备期末考试了，（嗯..期末就不想提了，太心痛！）那一备考阶段感觉是我上半年最迷茫的时候…所以就这样到7月中旬期末考试结束后我就回家了。接着就是半个月去福建福州和厦门的旅行，可以说是一次身心的放松吧。（虽然被晒得黑了两度！）可以看到页面最上面的背景照片就是我这次在厦门的一个沙滩所拍摄的！在这次更新中我觉得好看就放了上去，接下来谈谈这次的主题更新！ 2:主题更换 &emsp;&emsp;之前的主题一直用的是next主题，虽然网上的教程很多，但是无论什么样式看来看去真的很丑，所以最近几天就下决心换了一个主题，目前的样式就是所更换之后的主题，是一个中国程序员所编写的BlueLake主题，整个过程他在自己的github主题中写的很详细了，配置也不算太麻烦，感觉比之前的next主题好配置，（也可能我是更熟悉应用了）。所以整个过程没有之前费脑。目前我加上去的最好的功能感觉就是gittalk评论了，但是需要你登录自己的github账号，然后才能评论。我大部分配置的时间是花在了自定义blog的风格上面，这个主题和手机的适配真的也很好，这里就不具体讲这个blog的构造了，可以随处逛逛来自己理解！ 3：日后再要加上的功能 &emsp;&emsp;目前计划加上的功能有: 1:微信支付宝的打赏功能 2:被百度搜索引擎收录,并能查询到我的blog(目前已经被谷歌收录) 二：一些说明1：博客给谁看？&emsp;&emsp;在我写完这篇blog之前，我几乎没有公开过，甚至于我的舍友看了我的github才知道我写blog。原因首先是因为我的文章数目不够，当别人进来看的时候会不明白我的博客是用来做什么的，其次，我觉得我也没做好准备，目前了解和掌握的“技能点”很少，怕坚持不了第二点说明就自己投降了，没错重点是第二点说明： 2：每天写blog！&emsp;&emsp;嗯，从今天开始，也就是中国的情人节七夕，以后每天写一篇blog，一直到我写得不想写为止！我将受到所有人的共同监督！&emsp;&emsp;今天的blog算是一个继往开来的第零篇，摆脱过去，重新开始！","tags":[{"name":"DailyBlog","slug":"DailyBlog","permalink":"http://www.simbleman.com/tags/DailyBlog/"}]},{"title":"非常艰难的填坑之路","date":"2019-03-31T08:28:45.000Z","path":"2019/03/31/非常艰难的填坑之路/","text":"除了吃饭睡觉，这一天都在填一个其实只要用3行代码解决的坑，这中间伴随着郁闷和无尽的郁闷，甚至到达了怀疑自我的境界。。不过还好就在刚刚成功解决了。现在怀着非常激动的心情来叙说这个艰难的过程的结果。 缘由这个坑是有关JSON数据处理的，本来一点不了解这个数据格式的，上次在做微信小程序的时候偶然了解到了它，在做这个数据处理前，我以为会很简单。可是正是因为我的忽视，一开始浪费了很多时间在做无谓的工作。 关于json的微信小程序处理因为要选择一个客户端测试，所以就借用了微信小程序，要在java服务器中处理微信wx.request中的json数据，在微信小程序的js里面一定要先处理,不然等到它把数据发送到服务器端，会发现输出的一直是[object][object]一直看不到具体的对象的值，这时候叫天不应叫地不灵，无论在服务端怎么处理，都会发现是无用功，超级郁闷。123456789101112131415具体处理方法：json.stringify()方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串json.parse() 方法将数据转换为 JavaScript 对象( 将字符串转成json对象。 )js中的数据data: [&#123; &quot;coorx&quot;: 12, &quot;coory&quot;: 13 &#125;, &#123; &quot;coorx&quot;: 123, &quot;coory&quot;: 133 &#125;, &#123; &quot;coorx&quot;: 123, &quot;coory&quot;: 133 &#125; ]var arrJosn = JSON.stringify(this.data.data);传输的数据：data: &#123; &quot;data&quot;: arrJosn &#125;,只有这样data传到服务端才能正常显示，真坑啊。 服务端的处理在服务端发现是小程序中的json未处理前，在服务端我几乎把所有json处理的方式都试了一遍，但是没有效果。。但是试完了之后发现自己对json这个数据类型处理的思路也很清晰了。我用的是阿里巴巴的fastjson库。不过仔细想想我还是没有明白那个困惑我很久的情况：1234567891011121314151617181920212223 private static final String JSON_ARRAY_STR = &quot;[&#123;\\&quot;coory\\&quot;:13,\\&quot;coorx\\&quot;:12&#125;,&#123;\\&quot;coory\\&quot;:13,\\&quot;coorx\\&quot;:12&#125;,&#123;\\&quot;coory\\&quot;:13,\\&quot;coorx\\&quot;:12&#125;]&quot;; public static void main(String[] args)&#123; JSONArray jsonArray = JSON.parseArray(JSON_ARRAY_STR); System.out.println(jsonArray);&#125;以上代码运行一点问题都没有但是如果将JSON_ARRAY_STR变成另一种方法得到的，输出就会一直报错。 JSONArray jsonArray = new JSONArray(); for (int i = 0; i &lt; 3; i++) &#123; JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;coorx&quot;, 12); jsonObject.put(&quot;coory&quot;, 13); jsonArray.add(jsonObject); &#125; String str=jsonArray.toJSONString(); String JSON_ARRAY_STR=JSON.toJSONString(str); JSONArray jsa=JSON.parseArray(JSON_ARRAY_STR); 执行到最后一句一直报Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: syntax error, expect [, actual string, pos 0, fieldName null 但是你输出str2跟上面一种方法的JSON_ARRAY_STR一模一样。 无解啊 最后成功解决的原因就是不用把微信小程序处理过的数据再toJSONString。123String coor=request.getParameter(&quot;data&quot;);JSONArray jsa=JSONArray.parseArray(coor);这里直接parseArray于是就成功了转换成了json数组了。 总结这个坑的主要问题就是上面这些，虽然有些时候很多坑填填是必要的，但是这次的填坑之旅花费了大量的时间，而且非常艰难，这是我对这个问题的简单化造成的，一开始并没有想很系统的去了解和解决这个问题，总是想着网上copy其他人的代码节省时间，现在才发现自己去了解其中的原因和道理才是真正省时间的方法。嗯..还有很多问题等着去解决呢，还是不废话了。","tags":[{"name":"json","slug":"json","permalink":"http://www.simbleman.com/tags/json/"}]},{"title":"队列的实现","date":"2019-03-26T05:47:43.000Z","path":"2019/03/26/队列的实现/","text":"队列也是一种特殊的线性表，它的特点是先进先出，所有的插入操作都在表的一端进行，而删除操作都在表的另一端进行， 队列的指针实现因为队列要在线性表的两段进行操作，为了方便使用，就不能像栈那样只有个节点型就好了，因此它的定义和栈会有不同。 队列的定义和初始化1234567891011121314151617队列的节点定义struct node&#123; node *next; int element;&#125;;队列的定义struct QUEUE&#123; node * front;//表头节点 node * rear;//指向最后一个元素的节点&#125;;初始化void init(QUEUE &amp;q)&#123;//初始化为空表，头指针和尾指针重合 q.front=new node; q.front-&gt;next=NULL; q.rear=q.front; cout&lt;&lt;&quot;初始化成功&quot;&lt;&lt;endl;&#125; 插入操作（在队列的尾部进行）1234567void enqueue(int x,QUEUE &amp;q)&#123; q.rear-&gt;next=new node; q.rear=q.rear-&gt;next; q.rear-&gt;next=NULL; q.rear-&gt;element=x; cout&lt;&lt;&quot;插入队列成功&quot;&lt;&lt;endl;&#125; 删除操作（在队列的头部进行）1234567891011void dequeue(QUEUE &amp;q)&#123; node * temp; if(q.rear==q.front)&#123; cout&lt;&lt;&quot;错误，该队列为空！&quot;&lt;&lt;endl; &#125; else&#123; temp=q.front-&gt;next; q.front-&gt;next=temp-&gt;next; delete temp; &#125;&#125; 队列的数组实现（循环数组）因为队列的特殊性，一般的数组难以满足完美地满足它的要求，所以这里用循环数组来实现它。 队列的定义和初始化12345678910typedef struct&#123; int front; int rear; int elements[maxlength];&#125;QUEUE; void init(QUEUE &amp;Q)&#123;//将队列置为空 Q.front=0; Q.rear=maxlength-1;&#125; 注：为了防止循环队列队满和队空的状态相同，因此这里将rear比front滞后一个位置做为队空的状态，front为0，rear为maxlength-1，而把rear所指单元比front滞后两个位置做为队满的状态。 循环数组很重要的addone函数1234addone函数算是实现了循环数组循环的条件int addone(int i)&#123; return ((i+1)%maxlength);&#125; 插入操作（将rear往前移动一个位置（顺时针））1234567891011void insert(QUEUE &amp;Q,int x)&#123; if(addone(addone(Q.rear))==Q.front)&#123; cout&lt;&lt;&quot;错误，该队列已满！&quot;&lt;&lt;endl; &#125; else &#123; Q.rear=addone(Q.rear); Q.elements[Q.rear]=x; cout&lt;&lt;x&lt;&lt;&quot;插入队列成功！&quot;&lt;&lt;endl; &#125;&#125; 删除操作(将front往前移动一个位置（顺时针）)12345678void deleteq(QUEUE &amp;q)&#123; if(addone(q.rear)==q.front)&#123; cout&lt;&lt;&quot;错误，该附列已空&quot;&lt;&lt;endl; &#125; else&#123; q.front=addone(q.front); &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.simbleman.com/tags/数据结构/"},{"name":"队列","slug":"队列","permalink":"http://www.simbleman.com/tags/队列/"}]},{"title":"栈的实现","date":"2019-03-25T13:31:20.000Z","path":"2019/03/25/栈的实现/","text":"栈和队列都是一种特殊的线性表，因此都可以用指针和数组来实现它。在这里只实现他的一些关键的操作函数和方法。 栈的数组实现栈的数据逻辑特点是先进后出，所以一般用数组的最后位置当做栈的底部，而把数组开头的元素当做栈的顶部，因此入栈也称作压栈，且数据的删除和插入操作都只在栈的一端进行，因此栈的数据结构有int型的top，指向栈顶元素，还有一个数组用于存放栈的元素。 1：栈的数组结构体定义和初始化12345678910const int maxsize=100;struct STACK&#123; int top; int elements[maxsize];&#125;;void init(STACK &amp;s)&#123; s.top=maxsize;//当top为maxsize时，则栈为空 &#125; 2:push操作12345678910void push(STACK &amp;s,int x)&#123; if(s.top==0)&#123; cout&lt;&lt;&quot;错误，该栈已满&quot;&lt;&lt;endl; &#125; else&#123; s.top-=1; s.elements[s.top]=x; cout&lt;&lt;x&lt;&lt;&quot;压栈成功&quot;&lt;&lt;endl; &#125;&#125; 3:pop操作123456789void pop(STACK &amp;s)&#123; if(s.top==maxsize)&#123; cout&lt;&lt;&quot;错误，该栈为空&quot;&lt;&lt;endl; &#125; else&#123; s.top+=1; cout&lt;&lt;&quot;出栈成功，已删除栈顶元素&quot;&lt;&lt;endl; &#125;&#125; 注：其他操作功能可以根据需要进行设计 栈的指针实现栈的指针实现同数组实现，他的数据的插入和删除操作都在表头进行，和数组实现相比没有栈满的情况出现。 1:结构体定义及初始化1234567891011struct node&#123; node * next; int element;&#125;;typedef node * STACK;void init(STACK &amp;S)&#123;//初始化即将栈置空 S=new node; S-&gt;next=NULL; cout&lt;&lt;&quot;初始化成功！&quot;&lt;&lt;endl; &#125; 2:push操作12345678void push(STACK &amp;s,int x)&#123; STACK stk; stk=new node; stk-&gt;element=x; stk-&gt;next=s-&gt;next; s-&gt;next=stk; cout&lt;&lt;x&lt;&lt;&quot;入栈成功&quot;&lt;&lt;endl;&#125; 3:pop操作12345678910111213void pop(STACK &amp;s)&#123; STACK stk; cout&lt;&lt;s-&gt;next-&gt;element&lt;&lt;&quot;出栈成功！&quot;&lt;&lt;endl; if(s-&gt;next!=NULL)&#123; stk=s-&gt;next; s-&gt;next=stk-&gt;next; delete stk; &#125; else&#123; cout&lt;&lt;&quot;错误，该栈为空&quot;&lt;&lt;endl; &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.simbleman.com/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"http://www.simbleman.com/tags/栈/"}]},{"title":"线性表的实现","date":"2019-03-18T11:52:53.000Z","path":"2019/03/18/线性表的实现/","text":"最近在学习“数据结构和算法”这门课，刚学到了线性表这边，于是自己就课后用C++写了一下，但并没有用类的方式写它，单纯的用C的语言完成的，但写完后才发现跟自己在课上理解的所谓的线性表完全不一样。。 分类线性表的实现可以分为数组的实现和指针的实现，也称作顺序表和链表。这两种方法各有各的优缺点，但在这里要区分一下概念，一般我们所说的线性表是逻辑结构，顺序表和链表是存储结构。 数组实现本来想讲一讲struct的使用方法的，不过感觉有点偏离主题了，这里可以给出struct参考文章，其实只要了解和学习C++中的使用方法就基本可以了,如果有需要再去了解C语言中的用法。 1：结构体定义和初始化123456789101112#define maxlength 100struct list&#123; int elements[maxlength];//这里的int可以换成任何其他的数据类型 int last;//这是用以指示表中的最后一个元素在数组中的位置&#125;注意：数组实现方法中数组的开头不放元素，即elements[0]为空初始化：void init(list &amp;l)&#123; l.last=0;&#125;定义position：typedef int position; 2:插入和删除元素123456789101112131415161718192021222324252627void insertL(list &amp;l,position p,int x)//用形参引用可以改变实参的值 &#123; if(l.last&gt;=maxlength-1) cout&lt;&lt;&quot;Error! The list is full!&quot;; else if(p&gt;l.last+1||p&lt;=0) cout&lt;&lt;&quot;Error! The position does not exist!&quot;; else&#123; int i; for(i=l.last;i&gt;=p;i--)&#123; l.elements[i+1]=l.elements[i]; &#125; l.last+=1; l.elements[p]=x; &#125; &#125;void deleteL(list &amp;l,position p)&#123; int i; if(p&gt;l.last+1||p&lt;=0) cout&lt;&lt;&quot;Error! The position does not exist!&quot;; else&#123; for(i=p;i&lt;=l.last-1;i++)&#123; l.elements[i]=l.elements[i+1]; &#125; l.last-=1; &#125; 3：元素的查找1234567891011121314151617按值查找：int locateN(list &amp;l,int x)&#123; position q; for(q=1;q&lt;=l.last;q++)&#123; if(l.elements[q]==x)&#123; return q; &#125; &#125; return -1;//如果不存在就返回一个非正常数字&#125; 按位查找：int locateP(list &amp;l,int x)&#123; if(x&lt;1||x&gt;l.last) cout&lt;&lt;&quot;不存在这个位置的数据&quot;&lt;&lt;endl; else return l.elements[x]; &#125; 注：其他功能可以根据需要自己实现，这里就不一一实现了 指针实现线性表的指针实现主要是靠一个一个节点连接起来的，所以了解节点的概念很重要，还有一些C语言中用到的或者已经遗忘的知识点，这里简单回忆下new的用法，new是在C++中使用的动态内存分配，一般是给指针分配内存。底层调用malloc，返回的是void*指针类型。 1:结构体定义123456 struct node&#123; node * next; int element;&#125;;typedef node * LIST;typedef node * position; 2:初始化1234567void init(LIST &amp;l)&#123;//参数必须要为引用或者为一个指针 若为指针时，则传过来的实参要为地址 l=new node; //l=(LIST)malloc(sizeof(node));//malloc返回的是一个指针，等于从内存中获取空间 l-&gt;next=NULL; l-&gt;element=2;&#125;注：这里用new和malloc都可以的 3:插入和删除元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253bool insert(int x,int p,LIST &amp;l)&#123; int i; LIST L=l; LIST s; for(i=1;i&lt;p;i++)&#123; L=L-&gt;next; if(L==NULL) return false; &#125; s=(LIST)malloc(sizeof(node)); s-&gt;next=L-&gt;next; L-&gt;next=s; s-&gt;element=x; return true;&#125;注：p是指的第几个位置，其实时间复杂度只有O(1);分开写：void insertl(int x,position p)&#123;//实际的插入函数，复杂度只有O(1) position s; s=(LIST)malloc(sizeof(node)); s-&gt;next=p-&gt;next; p-&gt;next=s; s-&gt;element=x; cout&lt;&lt;&quot;插入成功！&quot;&lt;&lt;endl;&#125;bool insert(int x,int p,LIST &amp;l)&#123;//用来寻找position p int i; LIST L=l; for(i=1;i&lt;p;i++)&#123; L=L-&gt;next; if(L==NULL) return false; &#125; insertl(x,L); return true; &#125;bool deletel(int p,LIST &amp;l)&#123;//跟insert道理类似 int i; LIST L=l; LIST temp; for(i=1;i&lt;p;i++)&#123; L=L-&gt;next; if(L==NULL) return false; &#125; temp=L-&gt;next; L-&gt;next=temp-&gt;next; delete temp; return true;&#125; 4:查找元素123456789101112position locate(int x,LIST &amp;L)&#123; position p; p=L; while(p-&gt;next!=NULL)&#123; if(p-&gt;next-&gt;element==x)&#123; return p; //返回的是要查找元素的前一个位置 &#125; else p=p-&gt;next; &#125; return p;&#125; 总结顺序存储特点：长度固定，不易扩充，插入删除费时间O(n)，估算长度，浪费空间链式存储特点：长度灵活可变，易扩充，访问元素费时间O(n)，实际长度，节省空间。数组实现的方式中逻辑结构和物理结构相同，是连续的存储空间，而指针时不连续的存储空间。目前看来其实简单的线性表还是用数组实现更好，因为指针实现的insert和delete还要去找它的position，目前在我看来依旧很费时间。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.simbleman.com/tags/数据结构/"},{"name":"线性表","slug":"线性表","permalink":"http://www.simbleman.com/tags/线性表/"}]},{"title":"好久没更新了","date":"2019-03-12T13:11:31.000Z","path":"2019/03/12/好久没更新了/","text":"已经快有一个月没有更新了，有点惭愧。 主要是从准备开学到正式开学，一直都在做一个关于微信小程序的小项目，以前完全没有这方面的学习经历和经验，所以就从web的前端和后端一直看到了微信小程序。这其中总感觉时间不够用，所以一直很赶时间，就没有来更新博客了，但事实也证明了时间是不够用的。虽然这个小项目可能不会很完美结束，但这一个月还是学到了不少的。接下来我会尽量缩短我更新博客的时间，将这个月的经历一一分享。","tags":[]},{"title":"Linux的正则表达式基础","date":"2019-02-17T07:24:45.000Z","path":"2019/02/17/Linux的正则表达式基础/","text":"前言:在认识和学习bash的过程中，其中的通配符和让我印象深刻，当我了解到正则表达式时，它的功能同样让我感到惊讶，他们的相似之处有很多很多，因此经常会混淆他们的用法，但是这两者是完全不一样的东西！根据我的理解，通配符就像是bash中的特殊符号，可以直接被bash识别，最常用的用法是配合ls命令，进行查询操作的功能。而正则表达式则是一种字符串处理的表示方法，有很强大的字符串处理能力，可以信息进行加工和处理从而呈现出自己想要的信息。因为目前最经常用到的字符串选取工具程序是grep，所以就先用grep介绍最基本的正则表达式。 正文：先给出grep常用的语法参数：123456-c:&quot;查找字符串&quot;的次数-i: 忽略大小写的不同-n: 输出行号-v: 反向选择-A: (after)后面可加数字n，表示将后面的n行列出来-B: (before)前面可加数字n,表示将前面的n行列出来假设目标文件为text.txt1：查找特定字符串 grep -in &#39;the&#39; text.txt 查找文件中包含大小写the的字符串的所有行，并打印行号 grep -vn &#39;the&#39; text.txt 查找文件中不含the的字符串的所有行 2：利用中括号查找字符集合 grep -n &#39;t[ae]st&#39; text.txt 查找文件中包含tast或者test的字符串的所有行 grep -nA3 &#39;[^g]00&#39; text.txt 查找文件中包含oo字符串且前面没有字母g的的所有行，并且还输出符合条件行的后面三行。 grep -n &#39;[^a-z]oo&#39; text.txt 查找包含oo字符串，并且oo之前没有小写字母 注：小写字母还可以用[:lower:]表示，即[^a-z]等同于[^[:lower:]]不过初入门可以不用记忆太多，暂且先不列出这种特殊符号。 3:任意一个字符”.” grep -n &#39;g..d&#39; text.txt 选取含有g??d的字符串，即共有4个字符的所有行 4：重复字符”*” grep -n &#39;roo*t&#39; text.txt 选取含有以r开头t结尾且中间必定含有一个o的字符串，’ro*t’表示r和t中间可以含有零到无穷个o 注：如果想得到g开头和g结尾的字符串，我们经常会写成grep -n &#39;g*g&#39; text.txt而这个表示选取含有字母g的那一行，因为 g* 表示是空字符或者含有一个即以上的g。要想得到符合要求的字符串要写成grep -n &#39;g.*&#39;g text.txt 因为”.”表示的是任意一个字符,所以 .* 表示零个或任意一个字符的意思。 5：行首和行尾字符 grep -n &#39;^the&#39; text.txt 查找行首有the的所有行 grep -n &#39;^[a-z]&#39; text.txt 查找行首是小写字母的所有行 grep -n &#39;^[^a-zA-Z]&#39; text.txt 查找行首不是英文字母的所有行 这里注意^在[]里面和外面的不同含义哦！ 注：Linux里面的断行符是”$”,而windows中的断行符为”^M$”,所以行尾的标识符为$ grep -n &#39;\\.$&#39; text.txt 选取文本中以”.”（英文句号）结尾的所有行，这里的\\是转义字符，”\\.”表示解除”.”的特殊含义 grep -n &#39;^$&#39; text.txt 表示选取所有的空白行 综上所述，基础正则表达式字符： 字符 意义 ^word 要查找的字符串在行首 word$ 要查找的字符串在行尾 .(小数点) 代表一定有一个任意字符的字符 \\ 转义字符 * 重复前一个字符零次或者无数次 [] 从[]集合里面选出一个想要的字符 [n1-n2] 从n1到n2中选取一个想要的字符 [^] 从集合里面找出不要的字符串","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.simbleman.com/tags/Linux/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.simbleman.com/tags/正则表达式/"}]},{"title":"Hello World","date":"2019-02-15T16:22:17.208Z","path":"2019/02/16/hello-world/","text":"欢迎来到我的个人临时博客想着总要做点什么大一也像模像样的在阿里云上搞了一个传统的网站博客不过那只是出于好奇和尝试 那时什么也不懂什么也不会最后费时费力还费钱就没有继续搞下去了到了大二就想着总要做点什么于是就开始了重建之路为了节约和方便 现在的博客是基于托管服务的所以外观和界面都很简陋我也在不断地完善之中暂时就着当做是临时博客吧 成长还来得及还记得大一上刚学C++的时候从最一开始很吃力地写Hello World 到后来期末跟同学写小项目 跨越的过程还是花了很多时间和精力的不过也感觉到了自己的成长可能这将是一个漫长的过程所以希望能用博客记录我的成长和收获我也会将自己的心得和感想随时分享… 欢迎指正如果对网站或任何问题有什么意见或建议欢迎给我留言和指正目前的评论系统正在构建…请耐心等待…","tags":[{"name":"Hello World","slug":"Hello-World","permalink":"http://www.simbleman.com/tags/Hello-World/"}]}]