<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Haohao&#39;s Blog</title>
  
  <subtitle>To be a better man.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.simbleman.com/"/>
  <updated>2019-08-24T15:35:52.562Z</updated>
  <id>http://www.simbleman.com/</id>
  
  <author>
    <name>Haoocker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Blog_17_杂谈（可以忽略）</title>
    <link href="http://www.simbleman.com/2019/08/24/Blog-17-%E6%9D%82%E8%B0%88%EF%BC%88%E5%8F%AF%E4%BB%A5%E5%BF%BD%E7%95%A5%EF%BC%89/"/>
    <id>http://www.simbleman.com/2019/08/24/Blog-17-杂谈（可以忽略）/</id>
    <published>2019-08-24T15:35:05.000Z</published>
    <updated>2019-08-24T15:35:52.562Z</updated>
    
    <content type="html"><![CDATA[<p>今天的内容是杂谈，这两天的状态很糟糕，因此我今天不打算讲有关Flutter的东西。这两天负面的情绪可能将我大脑中旺盛的精力都抽干了，所以今晚暂停flutter，明天会继续更新Flutter的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天的内容是杂谈，这两天的状态很糟糕，因此我今天不打算讲有关Flutter的东西。这两天负面的情绪可能将我大脑中旺盛的精力都抽干了，所以今晚暂停flutter，明天会继续更新Flutter的&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
      <category term="杂谈" scheme="http://www.simbleman.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Bolg_16_flutter的按钮和更改页面数据</title>
    <link href="http://www.simbleman.com/2019/08/23/Bolg-16-flutter%E7%9A%84%E6%8C%89%E9%92%AE%E5%92%8C%E6%9B%B4%E6%94%B9%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE/"/>
    <id>http://www.simbleman.com/2019/08/23/Bolg-16-flutter的按钮和更改页面数据/</id>
    <published>2019-08-23T13:59:49.000Z</published>
    <updated>2019-08-23T14:00:24.647Z</updated>
    
    <content type="html"><![CDATA[<p>今天的内容是关于按钮和Flutter里面StateFulWidget的使用的，像Android里面的数据操作部分的逻辑是和页面分开写的，但是Flutter却不同，数据的操作和页面部分都是在同一个文件中来完成的。</p><h3 id="RaisedButton"><a href="#RaisedButton" class="headerlink" title="RaisedButton"></a>RaisedButton</h3><p>主要属性是两个：</p><ol><li>child:这里一般放置Button按钮里面的文字</li><li>Onpress(){}这是必须要重写的属性，主要是来设置按钮监听的动作<br>以上两个是RaisedButton经常使用的属性和方法，可能在以后会仔细来谈谈这个组件的其他的详细用法，今日主要大致了解便可<h3 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h3>今天之前所写的所有的小程序都是继承自StatelessWidget，这主要是用来存放一般的不可动的组件的，只要是不涉及数据或者是页面是静态的时候使用。<br>主要方法：<br>setState((){});这一般是在RaisedButton里面写，但需要更改数据的时候使用<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class HomePage extends StatefulWidget &#123;</span><br><span class="line">  HomePage(&#123;Key key&#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">  _HomePageState createState() =&gt; _HomePageState(); //箭头函数这里可以表示调用的意思</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _HomePageState extends State&lt;HomePage&gt; &#123;</span><br><span class="line">  int countNum = 0;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        SizedBox(height: 100,),</span><br><span class="line">        Chip(</span><br><span class="line">          label: Text(&apos;$&#123;this.countNum&#125;&apos;), //注意这里的数据绑定写法</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(&quot;按钮&quot;),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            setState(() &#123;</span><br><span class="line">              this.countNum++;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">注意数据的绑定一般是用“$&quot;符号，$&#123;数据&#125;。</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>到现在为止，应该是能够写出稍微复杂一点是页面了，希望在接下来的几天能写出一个小程序！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天的内容是关于按钮和Flutter里面StateFulWidget的使用的，像Android里面的数据操作部分的逻辑是和页面分开写的，但是Flutter却不同，数据的操作和页面部分都是在同一个文件中来完成的。&lt;/p&gt;
&lt;h3 id=&quot;RaisedButton&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="flutter" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/flutter/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_15_关于Row，Column和AspectRatio组件</title>
    <link href="http://www.simbleman.com/2019/08/22/Blog-15-%E5%85%B3%E4%BA%8ERow%EF%BC%8CColumn%E5%92%8CAspectRatio%E7%BB%84%E4%BB%B6/"/>
    <id>http://www.simbleman.com/2019/08/22/Blog-15-关于Row，Column和AspectRatio组件/</id>
    <published>2019-08-22T13:37:27.000Z</published>
    <updated>2019-08-22T13:37:47.713Z</updated>
    
    <content type="html"><![CDATA[<p>今天的内容是关于Row,Column,AspectRatio组件,大部分应该是以例子的形式展现。因为我今天写了太多的例子了</p><h3 id="Row和Column"><a href="#Row和Column" class="headerlink" title="Row和Column"></a>Row和Column</h3><p>常用的方法：</p><ol><li>mainAxisAlignment:主轴的对齐方式</li><li>crossAxisAlignment:垂直于主轴的对齐方式</li><li>Children<widget>[]这是放置子组件的属性<br>例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">    // TODO: implement build</span><br><span class="line"></span><br><span class="line">    return Container(child: Row(//column的使用方法和Row一模一样，不过是方向相反罢了</span><br><span class="line">      mainAxisAlignment: MainAxisAlignment.spaceEvenly,//水平轴的分配其主轴为水平轴</span><br><span class="line">      crossAxisAlignment: CrossAxisAlignment.end,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">      IconContainer(Icons.home,color: Colors.red),</span><br><span class="line">      IconContainer(Icons.search,color: Colors.blue),</span><br><span class="line">      IconContainer(Icons.select_all,color: Colors.yellow,)</span><br><span class="line">    ],),</span><br><span class="line">    width: 700.0,</span><br><span class="line">    height: 700.0,);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class IconContainer extends StatelessWidget &#123;</span><br><span class="line">       double size=32.0;//默认值</span><br><span class="line">    Color color=Colors.red;//这是默认值</span><br><span class="line">    IconData icon;//必传值</span><br><span class="line">    IconContainer(IconData icon,&#123;double size,Color color&#125;)&#123;</span><br><span class="line">      this.size=size;</span><br><span class="line">      this.icon=icon;</span><br><span class="line">      this.color=color;</span><br><span class="line">    &#125;</span><br><span class="line">    @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      height: 100.0,</span><br><span class="line">      width: 100.0,</span><br><span class="line">      color: this.color,</span><br><span class="line">      child: Center(</span><br><span class="line">        child: Icon(</span><br><span class="line">          this.icon,//传入的数据</span><br><span class="line">          size: this.size,//这是需要传入的数据</span><br><span class="line">          color: Colors.white,//这也是需要传入的数据</span><br><span class="line">        ),</span><br><span class="line">      ), </span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：上面的方法是通过一个类来封装了Widget的生成，必须传入Icon值，其他的值都是可选的，这很好的利用了类的特性来完成了这个功能。</span><br></pre></td></tr></table></figure></widget></li></ol><p>###AspectRatio组件<br>可以通过AspectRatio组件来设置宽度与高度的比例<br>经常可以用来制作横着平铺的图片或者组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">   // TODO: implement build</span><br><span class="line"></span><br><span class="line">   return AspectRatio(</span><br><span class="line">     aspectRatio: 3.0 / 1.0, //这个属性是宽度比上高度，什么也不设置的话宽度会自动填充，高度是宽度的三分之一</span><br><span class="line">     child: Container(color: Colors.red),</span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>小结：虽然这样的组件很多，也有很多组件的功能类似，但是如果能很好合适地利用，能减少很多的代码量，实现更好的适配效果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天的内容是关于Row,Column,AspectRatio组件,大部分应该是以例子的形式展现。因为我今天写了太多的例子了&lt;/p&gt;
&lt;h3 id=&quot;Row和Column&quot;&gt;&lt;a href=&quot;#Row和Column&quot; class=&quot;headerlink&quot; title=&quot;Row
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="flutter" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/flutter/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_14_FlutterGridView的剩余</title>
    <link href="http://www.simbleman.com/2019/08/21/Blog-14-FlutterGridView%E7%9A%84%E5%89%A9%E4%BD%99/"/>
    <id>http://www.simbleman.com/2019/08/21/Blog-14-FlutterGridView的剩余/</id>
    <published>2019-08-21T14:36:46.000Z</published>
    <updated>2019-08-21T15:16:56.503Z</updated>
    
    <content type="html"><![CDATA[<p>今天的内容是关于GridView的另一种实现的方式：GridView.Builder，这种实现方式很像之前的ListView.Builder,ListView.Builder会自动循环整个list的所有数据，所以需要index（下标）和length（list的长度），这样就可以来循环整个ListView进行数据的装配了。</p><h3 id="GridView-Builder"><a href="#GridView-Builder" class="headerlink" title="GridView.Builder()"></a>GridView.Builder()</h3><p>有几个常用且重要的属性:</p><ol><li>itemCount:这是循环数据的长度</li><li>itemBuilder:这是数据的来源,其参数是context和index，可以单独抽离出去形成一个函数来装配</li><li>gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(这是配置GridView水平或垂直表格之间的间距)<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">    // TODO: implement build</span><br><span class="line"></span><br><span class="line">    return Container(</span><br><span class="line">      child: GridView.builder(</span><br><span class="line">        itemCount: listData.length,</span><br><span class="line">        itemBuilder: this._getListData,</span><br><span class="line">        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">            crossAxisCount: 2,</span><br><span class="line">            crossAxisSpacing: 10.0,//水平Widget之间的间距</span><br><span class="line">            mainAxisSpacing: 10.0),//垂直Widget之间的间距</span><br><span class="line">      ),</span><br><span class="line">      padding: EdgeInsets.all(10.0),//通过Container来增加边框</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Widget _getListData(context, index) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      alignment: Alignment.center,</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">        border: Border.all(</span><br><span class="line">            color: Color.fromRGBO(233, 233, 233, 0.9),</span><br><span class="line">            width: 2.0), //注意这里不是Colors</span><br><span class="line">        //在Decoration里面的border属性里面添加border</span><br><span class="line">      ),</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Image.network(listData[index][&quot;imageUrl&quot;]),</span><br><span class="line">          SizedBox(height: 10.0), //这里用Container也可以，但SizedBox更合适</span><br><span class="line">          Text(</span><br><span class="line">            listData[index][&quot;title&quot;],</span><br><span class="line">            style: TextStyle(fontSize: 20.0),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>GridView大概就这么多用法，今天其实还进行了Padding的学习，但是目前，我尽量将自己的博文时间减少这样会导致内容减少，但是我需要用更多的时间来加快我的进度，所以最近可能文章的长度大概就会这么多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天的内容是关于GridView的另一种实现的方式：GridView.Builder，这种实现方式很像之前的ListView.Builder,ListView.Builder会自动循环整个list的所有数据，所以需要index（下标）和length（list的长度），这样就
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="flutter" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/flutter/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_13_Flutter的GridView</title>
    <link href="http://www.simbleman.com/2019/08/20/Blog-13-Flutter%E7%9A%84GridView/"/>
    <id>http://www.simbleman.com/2019/08/20/Blog-13-Flutter的GridView/</id>
    <published>2019-08-20T15:07:53.000Z</published>
    <updated>2019-08-20T15:08:20.735Z</updated>
    
    <content type="html"><![CDATA[<p>Flutter中的GridView给人的感觉还是挺不一样的，有一种很方便控制的感觉（相比于Android）不说了直接上代码吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Widget&gt; _getListData() &#123;</span><br><span class="line">    List&lt;Widget&gt; list = new List();</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">      list.add(Container(</span><br><span class="line">        child: Text(</span><br><span class="line">          &quot;这是第$i个数据&quot;,</span><br><span class="line">          style: TextStyle(color: Colors.blue, fontSize: 20),</span><br><span class="line">        ),</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        color: Colors.red,</span><br><span class="line">        //直接在Container里面定义高度和宽度是没有意义的，没有反应，要用到childAspectRatio(宽度比高度)</span><br><span class="line">        //height: 400.0,</span><br><span class="line">      ));</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br><span class="line">GridView.count(</span><br><span class="line">      children: _getListData(),</span><br><span class="line">      crossAxisCount: 2,</span><br><span class="line">      crossAxisSpacing: 20.0,//网格之间左右的间距</span><br><span class="line">      mainAxisSpacing: 20.0,//网格之间上下的间距</span><br><span class="line">      padding: EdgeInsets.all(10.0),//这是网格整体上下的外边框</span><br><span class="line">      childAspectRatio: 0.7,//宽度和高度的比值</span><br><span class="line"></span><br><span class="line">    );</span><br></pre></td></tr></table></figure></p><p>注：GridView有两种实现方法：<br>1:GridView.count();<br>2:GridView.builder();<br>上面的代码就是一种实现方法，下面的一种方法今天暂且先不展示了。</p><p>因为今天的时间关系，没有来得及将GridView部分全部看完，所以明天可能会继续GridView，因为今天忙着去做了一些不得不做的事，所以就耽误了很长的时间，那明天继续吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Flutter中的GridView给人的感觉还是挺不一样的，有一种很方便控制的感觉（相比于Android）不说了直接上代码吧！&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="flutter" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/flutter/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_11_杂谈（可以忽略）</title>
    <link href="http://www.simbleman.com/2019/08/18/Blog-11-%E6%9D%82%E8%B0%88%EF%BC%88%E5%8F%AF%E4%BB%A5%E5%BF%BD%E7%95%A5%EF%BC%89/"/>
    <id>http://www.simbleman.com/2019/08/18/Blog-11-杂谈（可以忽略）/</id>
    <published>2019-08-18T14:10:09.000Z</published>
    <updated>2019-08-18T14:10:37.994Z</updated>
    
    <content type="html"><![CDATA[<p>今天是星期日，今天不谈Flutter，但我不知道今天的内容应该是什么。<br>嗯…还是谈谈接下来的Flutter的更新的内容吧，可能最近有点焦急了，因为各方面原因，Flutter的进展很缓慢，虽然总体来讲，并没有android那样让我很困扰，但是这样的进展速度总是很让人焦虑..嗯..可能不需要我太多废话，今天就是抱怨一下最近的自己，明天开始继续Flutter！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是星期日，今天不谈Flutter，但我不知道今天的内容应该是什么。&lt;br&gt;嗯…还是谈谈接下来的Flutter的更新的内容吧，可能最近有点焦急了，因为各方面原因，Flutter的进展很缓慢，虽然总体来讲，并没有android那样让我很困扰，但是这样的进展速度总是很让人焦虑
      
    
    </summary>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
      <category term="杂谈" scheme="http://www.simbleman.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Blog_10_FlutterImage的一小部分</title>
    <link href="http://www.simbleman.com/2019/08/17/Blog-10-FlutterImage%E7%9A%84%E4%B8%80%E5%B0%8F%E9%83%A8%E5%88%86/"/>
    <id>http://www.simbleman.com/2019/08/17/Blog-10-FlutterImage的一小部分/</id>
    <published>2019-08-17T14:54:11.000Z</published>
    <updated>2019-08-17T14:57:15.091Z</updated>
    
    <content type="html"><![CDATA[<p>今天是写Blog的第十天，依旧是Flutter，依旧是Flutter的一小部分，今天的部分主要是关于Flutter的Image组件或者说是Image Widge。</p><h3 id="Image相关"><a href="#Image相关" class="headerlink" title="Image相关"></a>Image相关</h3><p>image下有几个constructor其中包含了4个命名构造函数：</p><ul><li>new Image 从一个ImageProvider获取image</li><li>new Image.asset   从本地文件夹获取数据</li><li>new Image.network    从网络中获取数据</li><li>new Image.file       从File中获取数据</li><li>new Image.memory     从 Uint8List中获取数据<br>注意：后面两个并不是很常用，所以就不介绍了<h4 id="Image-network"><a href="#Image-network" class="headerlink" title="Image.network"></a>Image.network</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: NetworkImage(&quot;https://raw.githubusercontent.com/Haoocker/Haoocker.github.io/master/img/avatar.png&quot;),fit: BoxFit.cover)</span><br></pre></td></tr></table></figure></li></ul><h4 id="Image-asset"><a href="#Image-asset" class="headerlink" title="Image.asset"></a>Image.asset</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">child: ClipOval(child: Image.asset(&quot;images/picture.jpg&quot;,</span><br><span class="line">                                    width: 200,</span><br><span class="line">                                    height: 200,</span><br><span class="line">                                    fit:  BoxFit.cover)</span><br><span class="line">)//注意：加载本地图片的时候记得要建立文件夹并且在文件中配置它</span><br></pre></td></tr></table></figure><p> 嗯…今天的内容就先到这里结束了，比较简短，虽然有点偷懒的写法，但是确实是没有什么好写的，当我把整体基础部分写完之后可能才会更有趣些吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是写Blog的第十天，依旧是Flutter，依旧是Flutter的一小部分，今天的部分主要是关于Flutter的Image组件或者说是Image Widge。&lt;/p&gt;
&lt;h3 id=&quot;Image相关&quot;&gt;&lt;a href=&quot;#Image相关&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="flutter" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/flutter/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_09_使用Flutter的第一个页面</title>
    <link href="http://www.simbleman.com/2019/08/16/Blog-09-%E4%BD%BF%E7%94%A8Flutter%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2/"/>
    <id>http://www.simbleman.com/2019/08/16/Blog-09-使用Flutter的第一个页面/</id>
    <published>2019-08-16T13:08:22.000Z</published>
    <updated>2019-08-16T13:46:47.437Z</updated>
    
    <content type="html"><![CDATA[<p>终于开始将flutter的布局开始了解和学习了，经过这一天和它的接触，发现它真的比Android要好用一点，没有像Android那么多复杂的配置和不知道怎么写Java代码的困扰。flutter中的dart还是挺容易去了解和学习的。</p><h4 id="初次开发"><a href="#初次开发" class="headerlink" title="初次开发"></a>初次开发</h4><div align="center"><br>  <img width="300" src="/images/flutter.jpg"><br></div><p>Flutter的开发相对android开发目前印象良好，因为它简便地多，可以不再用那个很难搞懂的android studio开发了，不过唯一使用下来感觉是前端界面如果比较复杂，真的代码就看不懂了，因为flutter的界面设计并没有像android那样可以在android studio中进行可视化设计，所以界面都是靠代码堆叠起来的，因此一旦界面复杂，那么代码的可读性真的很糟糕。<br>今天并不打算介绍我的全部代码，因为它的可读性问题，可能我在后面有时间的时候会再来修改一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;终于开始将flutter的布局开始了解和学习了，经过这一天和它的接触，发现它真的比Android要好用一点，没有像Android那么多复杂的配置和不知道怎么写Java代码的困扰。flutter中的dart还是挺容易去了解和学习的。&lt;/p&gt;
&lt;h4 id=&quot;初次开发&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="flutter" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/flutter/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_08_dart重写小程序</title>
    <link href="http://www.simbleman.com/2019/08/15/Blog-08-dart%E9%87%8D%E5%86%99%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://www.simbleman.com/2019/08/15/Blog-08-dart重写小程序/</id>
    <published>2019-08-15T14:55:32.000Z</published>
    <updated>2019-08-15T14:57:17.392Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天的文章是关于我用dart语言重写我之前的一个代码的例子，以后我也会尽量从这样的例子中来说明一个语法或者一个问题！<br>&emsp;&emsp;不得不说dart与C++比起来好像并没有那么复杂，语法比较简单明了！</p><p>####简单例子1<br>首先来看在C++中的源代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int i,j;</span><br><span class="line">        for(i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">        for(j=i+1;j&lt;nums.size();j++)&#123;</span><br><span class="line">        if(nums[i]+nums[j]==target)&#123;</span><br><span class="line">        return &#123;i,j&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>下面是我用dart重写之后的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line"> List&lt;int&gt; twoSum(List&lt;int&gt; nums,int target)&#123;</span><br><span class="line">   //在dart中返回类型也可以不写，且方法没有加_一律都是公有方法</span><br><span class="line">    for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">      for(int j=i+1;j&lt;nums.length;j++)&#123;</span><br><span class="line">        if(nums[i]+nums[j]==target)</span><br><span class="line">          return [i,j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [];//返回一个空的List</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####简单例子2<br>这同样是C++的代码，是上面代码的改进版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution2 &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        map&lt;int,int&gt; a;//建立hash表存放数组元素</span><br><span class="line">        vector&lt;int&gt; b(2,-1);//存放结果</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">            a.insert(map&lt;int,int&gt;::value_type(nums[i],i));</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a.count(target-nums[i])&gt;0&amp;&amp;(a[target-nums[i]]!=i))</span><br><span class="line">            //a.count(键值)返回0或1，代表是否存在键值</span><br><span class="line">            &#123;</span><br><span class="line">                b[0]=i;</span><br><span class="line">                b[1]=a[target-nums[i]];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>同样，可以用dart来改写一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution2&#123;</span><br><span class="line">  twoSum(List&lt;int&gt; nums,int target)&#123;</span><br><span class="line">    Map a=new Map();</span><br><span class="line">    //这里不可以用在C++中定义Map的方法：Map&lt;int&gt;&lt;int&gt; map;</span><br><span class="line">    //因为在dart中一切都是对象，所以这样的定义方法会简单很多</span><br><span class="line">    //甚至可以不加new关键词 Map a=Map();</span><br><span class="line">    List list=new List&lt;int&gt;();</span><br><span class="line">    for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">      a.addAll(&#123;nums[i]:i&#125;);</span><br><span class="line">      //向Map中添加数据，一般用addAll函数，注意写法</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">      if(a.containsKey(target-nums[i])&amp;&amp;a[target-nums[i]]!=i)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">        list.add(a[target-nums[i]]);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>不得不说，在Dart中没有C++中那么复杂的Map定义和使用，不过也只有当很熟练掌握之后dart之后才能发挥更大的功效。</p><p>####关于flutter<br>这两天我在自己的电脑上完成了flutter环境的搭建以及分别在vscode中和android studio中搭建了flutter的环境。flutter的正式介绍应该是从明天开始！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;今天的文章是关于我用dart语言重写我之前的一个代码的例子，以后我也会尽量从这样的例子中来说明一个语法或者一个问题！&lt;br&gt;&amp;emsp;&amp;emsp;不得不说dart与C++比起来好像并没有那么复杂，语法比较简单明了！&lt;/p&gt;
&lt;p&gt;####简单例子1
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="flutter" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/flutter/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_07_关于内容的杂谈</title>
    <link href="http://www.simbleman.com/2019/08/14/Blog-07-%E5%85%B3%E4%BA%8E%E5%86%85%E5%AE%B9%E7%9A%84%E6%9D%82%E8%B0%88/"/>
    <id>http://www.simbleman.com/2019/08/14/Blog-07-关于内容的杂谈/</id>
    <published>2019-08-14T15:09:25.000Z</published>
    <updated>2019-08-14T15:10:56.427Z</updated>
    
    <content type="html"><![CDATA[<p>其实了解下来感觉dart就是各种语言的大杂烩，你可以看见java的影子，你也可以看见JavaScript的影子，你甚至可以看见swift的影子，难怪说flutter是跨平台的呢，从这个语言的特征就能看出来了。</p><p>###我想说的<br>因为最近的Blog大部分都是这种知识类型的介绍，这是我学习成果的展示，也是我学习的过程。但由于在学习的过程中，我已经完成了大部分代码的编写，所以当我在写Blog的时候，设计代码的部分我会选择直接将我写好的代码拿过来复制粘贴，虽然能节省我写Blog的很多时间，可是这完全就是一种无意义的行为，因此从今天开始，我只会将我总结性的内容呈现出来，而不再是过程性的知识。</p><p>###所以今天不再是dart相关的基础内容<br>我思考了一下，决定今天的内容不再和dart相关，这个内容可能需要我接下来思考一下以什么样的方式呈现出来，所以今天纯粹是一种杂谈，本来打算是关于dart的剩下内容关于函数和类，我却发现其实这样的方式是有一定的问题的，因此今天暂停这样的内容呈现方式！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实了解下来感觉dart就是各种语言的大杂烩，你可以看见java的影子，你也可以看见JavaScript的影子，你甚至可以看见swift的影子，难怪说flutter是跨平台的呢，从这个语言的特征就能看出来了。&lt;/p&gt;
&lt;p&gt;###我想说的&lt;br&gt;因为最近的Blog大部分都是
      
    
    </summary>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
      <category term="杂谈" scheme="http://www.simbleman.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Blog_06_Dart基础</title>
    <link href="http://www.simbleman.com/2019/08/13/Blog-06-Dart%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.simbleman.com/2019/08/13/Blog-06-Dart基础/</id>
    <published>2019-08-13T13:39:02.000Z</published>
    <updated>2019-08-13T13:40:09.374Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要是了解了dart相关的一些最基本的知识，并尝试在vscode和android studio中搭建了flutter环境，在vs code中进行flutter环境的搭配是要用到第三方的插件，但由于flutter还并没有像android那样火爆，因此并没有一个专门为他设计的ide，在android studio中也可以搭建flutter环境，也是像在vs code中需要借助第三方插件来进行开发。</p><h3 id="dart语言基础"><a href="#dart语言基础" class="headerlink" title="dart语言基础"></a>dart语言基础</h3><p>在<a href="https://dart.dev" target="_blank" rel="noopener">dart官网</a>,可以获得到所有关于dart环境安装的必需下载。也会有关于安装步骤的说明，当然你也可以去网上搜索教程来学习。</p><p>####dart一些常见和特殊的语法用法</p><ol><li>main函数<br>dart中函数的定义一般都是(){}的形式，main函数也不例外。一种定义的方法:main(){}还有一种定义的方法是:void main(){}</li><li><p>字符串的拼接<br>字符串的拼接可以像c语言或者java中用”+”完成，还有一种方式是使用$特殊符号完成（类似于引用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string1=&quot;Hello,&quot;;</span><br><span class="line">var string2=&quot;world!&quot;;</span><br><span class="line">print(string1+string2);</span><br><span class="line">print(&quot;$string1 $string2&quot;);//加双引号</span><br></pre></td></tr></table></figure></li><li><p>函数<br>dart中函数的定义和C++，java中的大同小异。不过还是有特殊的定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义一个可选参数的函数：</span><br><span class="line">String printUserInfo(String username,[int age,String sex=&apos;男&apos;])&#123;//可选参数用中括号，默认参数可以在可选参数中设置</span><br><span class="line">if(age!=null)</span><br><span class="line">  return &quot;姓名: $username===年龄:$age&quot;;</span><br><span class="line">else</span><br><span class="line">  return &quot;姓名: $username===年龄:保密&quot;;</span><br><span class="line">&#125;</span><br><span class="line">print(printUserInfo(&quot;张三&quot;));</span><br><span class="line">//在这里函数的调用过程中，省去了age和sex，因为这是在函数的形参中被定义成了可选参数，sex还是一个默认参数。</span><br></pre></td></tr></table></figure></li></ol><p>4.变量<br>因为dart的强语言特性，所以dart可以不预先定义变量类型，用var,例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;您好dart&quot;;</span><br><span class="line">var num=123;</span><br><span class="line">//也可以通过明示来定义变量</span><br><span class="line">String str=&quot;hello world&quot;;</span><br><span class="line">print(str);</span><br><span class="line">//变量的名称是区分大小写的</span><br></pre></td></tr></table></figure></p><p>####dart中关于List和map相关</p><ol><li><p>定义<br>list和map都有两种定义的方法，一种是直接定义法，如List：<code>var list=[123,12334,321321];</code>第二种是<code>var list=new List();list.add(123);</code><br>map：<code>第一种定义的方式：<br>var person={<br> “name”:”张三”,<br> “phone”:1234 ,<br> “work”:{<br>   “work1”:”常州”,<br>   “work2”:”南京”<br> }<br>};<br>第二种定义的方式：<br>var p=new Map();<br>p[“name”]=”李四”;<br>p[“age”]=22;</code></p><ol start="2"><li>增加和删除数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">增加数据：</span><br><span class="line">list:</span><br><span class="line">  list.add(&quot;桃子&quot;);//增加一个数据</span><br><span class="line">  list.addAll([&quot;栗子&quot;,&quot;杏子&quot;]);//传入的是一个数组,相当于是拼接数组</span><br><span class="line"></span><br><span class="line">  map:只有一种增加数据的方法</span><br><span class="line">  person.addAll(&#123;</span><br><span class="line">  &quot;work&quot;:[&apos;码农&apos;,&apos;教师&apos;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  删除数据：</span><br><span class="line">  list:</span><br><span class="line">list.remove(&apos;苹果&apos;); //根据名称删除</span><br><span class="line">print(list);</span><br><span class="line">list.removeAt(1);//根据下标删除</span><br><span class="line">print(list);</span><br></pre></td></tr></table></figure></li><li><p>遍历list和map的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1:用for循环:类似于C++和java中那样的循环</span><br><span class="line">2:用item</span><br><span class="line">for( var item in list)&#123;</span><br><span class="line">   print( item);</span><br><span class="line">&#125;</span><br><span class="line">3：用foreach</span><br><span class="line">list.forEach((value)&#123;</span><br><span class="line">  print(&quot;$value&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>set相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set用它最主要的功能就是去除数组重复的内容</span><br><span class="line">var newset=new Set();</span><br><span class="line">newset.add(&apos;苹果&apos;);</span><br><span class="line">newset.add(&apos;香蕉&apos;);</span><br><span class="line">newset.add(&apos;苹果&apos;);</span><br><span class="line">print(newset);</span><br><span class="line">只会打印出两个数值，因为有&quot;苹果&quot;重复了</span><br><span class="line">print(newset.toList());</span><br><span class="line">将set可以轻易转换成list</span><br></pre></td></tr></table></figure></li></ol><p>####dart语言特性</p><ol><li>强类型语言，变量的类型指定不一定要标明，因为Dart可以推断出它的类型。</li><li>在dart语言中，所有对象的类都是一个类的实例，甚至是整数，函数，null也看作对象<br>暂且所了解的比较深刻的就是这两点，所以暂且先列出这两点</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天主要是了解了dart相关的一些最基本的知识，并尝试在vscode和android studio中搭建了flutter环境，在vs code中进行flutter环境的搭配是要用到第三方的插件，但由于flutter还并没有像android那样火爆，因此并没有一个专门为他设计
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="flutter" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/flutter/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_05:关于flutter框架的了解</title>
    <link href="http://www.simbleman.com/2019/08/12/Blog-05-%E5%85%B3%E4%BA%8Eflutter%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
    <id>http://www.simbleman.com/2019/08/12/Blog-05-关于flutter框架的了解/</id>
    <published>2019-08-12T14:54:46.000Z</published>
    <updated>2019-08-13T13:40:07.376Z</updated>
    
    <content type="html"><![CDATA[<p>经过大概半天的思考，最终决定还是先从dart开始了解，再去了解futter这个谷歌的新型跨平台框架。这样看起来android都已经要过时了呢。</p><h3 id="flutter：一个跨平台的框架"><a href="#flutter：一个跨平台的框架" class="headerlink" title="flutter：一个跨平台的框架"></a>flutter：一个跨平台的框架</h3><p>相信很多人都有听说过flutter，几乎从去年的谷歌io大会之后flutter就很火。各种说法蜂拥而至，这让flutter受到了前所未有的关注。据官网介绍，国内的闲鱼平台二手商品的的详细界面就是使用flutter写成的，一套代码，就完成了在android和ios系统上运行的要求。因为他优秀的跨平台性和他流畅的运行结果，而且学习和使用这个框架也不是很难，所以我也被吸引到了解和学习他的过程中。</p><h3 id="dart语言"><a href="#dart语言" class="headerlink" title="dart语言"></a>dart语言</h3><p>flutter使用dart语言，所以了解flutter，先学会dart是很有必要的。dart的很多语法和java很像，因为今天时间的原因，没有将dart详细了解，只是粗略的看了一下，同时今天也将dart的运行环境搭建完成，因为国内网络的原因，所以在一开始的下载过程中遇到了很大的影响，但是一旦下载好sdk，就能容易进行环境的搭建啦，今天就先这样草草结束，从明天开始将正式讲解dart的语法和使用！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过大概半天的思考，最终决定还是先从dart开始了解，再去了解futter这个谷歌的新型跨平台框架。这样看起来android都已经要过时了呢。&lt;/p&gt;
&lt;h3 id=&quot;flutter：一个跨平台的框架&quot;&gt;&lt;a href=&quot;#flutter：一个跨平台的框架&quot; class=&quot;
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="flutter" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/flutter/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_04:杂谈</title>
    <link href="http://www.simbleman.com/2019/08/11/Blog-04-%E6%9D%82%E8%B0%88/"/>
    <id>http://www.simbleman.com/2019/08/11/Blog-04-杂谈/</id>
    <published>2019-08-11T14:21:54.000Z</published>
    <updated>2019-08-11T14:23:46.262Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天是周日，因此就和自己的朋友出去聚了聚餐，聊了很多，关于很多。所以今天的学习内容没有，主要是自己的一些观点和感悟。</p><h3 id="关于程序员和编程"><a href="#关于程序员和编程" class="headerlink" title="关于程序员和编程"></a>关于程序员和编程</h3><p>&emsp;&emsp;编程的这条道路对每个程序员来说是必不可少的，也是非常艰辛的，之前的一段时间一直有新闻爆料一个又一个程序员倒在了自己的工作岗位上，同时也在爆料一个又一个大型互联网公司实行996工作制度，这引起了很多程序员的不满，也引起了社会的广泛关注。<br>&emsp;&emsp;在我看来，程序员的这个职位就是个搬砖的，纯粹是在用自己的纯劳动力换取工资，因此这不是什么大家以为的很高科技很炫酷的岗位，也不是大家看见电影里面的那种坐在电脑前面敲几行代码就能攻破美国国家国防部的防御墙。在这个岗位上你是敲着自己的代码，并且要为一个公司的利润和业绩带来提升的，如果你真的可以几行代码就能搞定一切，那么你也不会去公司找工作，你也不会来做程序员。因此程序员就是很普通的一类人，不错是用自己的脑力和体力换取工资和金钱的。<br>&emsp;&emsp;想要成为一名程序员，门槛也不是很高，所以为什么大家都会跳槽来这个岗位，除了高工资高待遇，可能也有这一部分原因。程序员的主要工作当然是编程，因此编程很重要，从我大一接触计算机以来，也不过只学了C++,java等语言，因此我们掌握的东西还很有限，能运用的场景也不是很多，所以是要不断加强语言的掌握程度的。因此接下来的一段时间里，我可能集中叙述一些java相关和一些其他语言的。我觉得可能我会尽可能增加自己的实际例子来穿插。<br>&emsp;&emsp;嗯..今天的杂谈到这里就先匆匆结束了。晚安，我们明天再见</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;今天是周日，因此就和自己的朋友出去聚了聚餐，聊了很多，关于很多。所以今天的学习内容没有，主要是自己的一些观点和感悟。&lt;/p&gt;
&lt;h3 id=&quot;关于程序员和编程&quot;&gt;&lt;a href=&quot;#关于程序员和编程&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
      <category term="杂谈" scheme="http://www.simbleman.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Blog_03:补充git的剩余部分</title>
    <link href="http://www.simbleman.com/2019/08/10/Blog-03-%E8%A1%A5%E5%85%85git%E7%9A%84%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86/"/>
    <id>http://www.simbleman.com/2019/08/10/Blog-03-补充git的剩余部分/</id>
    <published>2019-08-10T13:48:10.000Z</published>
    <updated>2019-08-10T13:48:59.934Z</updated>
    
    <content type="html"><![CDATA[<p>今天是台风登陆大陆的一天，也是一个周末，所以今天的内容不会太多，就是补充昨天git的剩余关于分支(branch)的部分。</p><h3 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h3><p>在这里需要了解一下git是如何保存数据的：git保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。在进行提交操作的时候，，Git会保存一个提交对象。git的分支，本质上就是指向提交对象的可变指针。</p><h4 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h4><pre><code>git branch testing 只会创建一个testing分支。</code></pre><p>注意：git的默认分支名字是master，当使用git init命令的时候自动创建，同时git有一个名为HEAD的特殊指针，他是一个指向当前所在的本地分支，默认是master，所以要切换指针的的话要用到下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout testing切换到分支testing，这样HEAD会指向testing</span><br><span class="line">git checkout -b testing 会创建一个分支testing并自动切换到分支上去</span><br><span class="line">git log --oneline --decorate --graph --all 它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</span><br></pre></td></tr></table></figure><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>如果当你已经完成了testing分支的工作，想要把testing分支合并到主分支中去（也就是master）可以运行git merge<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master切换到master分支</span><br><span class="line">git merge testing 将testing分支合并到master</span><br></pre></td></tr></table></figure></p><p>注意：如果在两个分支中对同一个文件的同一个部分进行了不同的修改，则会产生冲突，这时候当你merge的时，git会暂停下来等待你去解决合并产生的冲突。</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><pre><code>git branch -v可以查看每个分支的最后一次提交git branch -d可以删除掉当前分支（需要注意这是你已经合并之后的不需要的分支）</code></pre><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><pre><code>git ls-remote (remote) 来 显式地获得远程引用的完整列表</code></pre><p>首先你需要知道当你clone一个仓库之后，你的本地会产生一个master分支，而服务器上的master分支在本地会变成origin/master，但你看见这个就代表是服务器上的master了。 git fetch origin会拉取服务器上的master的所有数据，更新本地的数据库。当你git fetch之后本地的master分支依旧是没有变化的，还需要加上git merge来手动合并服务器上的数据。但是当你使用了git pull便可以拉取数据并自动合并到当前所指的分支。这也是昨天所说的：git pull=git fetch+git merge.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是台风登陆大陆的一天，也是一个周末，所以今天的内容不会太多，就是补充昨天git的剩余关于分支(branch)的部分。&lt;/p&gt;
&lt;h3 id=&quot;git分支&quot;&gt;&lt;a href=&quot;#git分支&quot; class=&quot;headerlink&quot; title=&quot;git分支&quot;&gt;&lt;/a&gt;git
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_02:关于git和github</title>
    <link href="http://www.simbleman.com/2019/08/09/Blog-02-%E5%85%B3%E4%BA%8Egit%E5%92%8Cgithub/"/>
    <id>http://www.simbleman.com/2019/08/09/Blog-02-关于git和github/</id>
    <published>2019-08-09T14:33:47.000Z</published>
    <updated>2019-08-09T14:38:23.120Z</updated>
    
    <content type="html"><![CDATA[<p><code>工欲善其事必先利其器</code><br>github被戏称为是世界上最大的同性社交平台，这肯定是有它自己独特的魅力。我也很早就被他的这种魅力所吸引，但是终究只是沉醉于它那富丽堂皇的表面，而迟迟没有去欣赏它真实的内涵。</p><h3 id="git和github"><a href="#git和github" class="headerlink" title="git和github"></a>git和github</h3><p>&emsp;&emsp;<a href="https://github.com/" target="_blank" rel="noopener">github</a>简单来说是一个代码托管平台，你可以将自己的项目代码放到这个平台中去，这是一个公开的平台，所有人将可以看见你的项目的代码，除非你买了私人的github账号和仓库。在我的理解中这就是程序员们交流的一个平台，全世界所有的程序员在这个平台中是平等的，说全世界是因为这大概是为数不多的没有被中国所墙掉的网站，你可以在这个平台上可以展示自己的项目的代码，也可以免费看到那些优秀程序员的项目的源代码，还可以在项目中提出issue和作者交流。<br>&emsp;&emsp;而git算是github网站的核心技术，git是什么，在廖雪峰的官方网站上他写到：“Git是目前世界上最先进的分布式版本控制系统（没有之一）。” 可以说这是对git很高很高的评价了。一开始了解git可能我们都并不是很了解为什么要这么说，但当你了解到一定程度之后你会发现，“嗯…好像真的有点厉害”。好了废话这么多就正式进入正题！</p><h3 id="git工作的三个区域"><a href="#git工作的三个区域" class="headerlink" title="git工作的三个区域"></a>git工作的三个区域</h3><p>学习git首先要了解的就是git做为版本控制系统的三个最基本的区域。这也是git很多命令理解的前提和关键</p><ol><li>git仓库<br>我个人的理解就是最终代码和文件的存放的区域，一般是你把所有暂时不需要修改的代码和文件放在这个区域。相当于一个产品暂时最终的样子，说是暂时的因为你还可以再次修改，修改完成之后还可以覆盖掉原来的产品。</li><li>工作目录<br>可以理解成你完成代码的编写和文件的修改等等的区域，相当于一个产品的车间，你在这里完成一切产品的加工和创造</li><li>暂存区域<br>顾名思义。这里的文件和代码是在工作目录完成之后暂存的，准备提交到git仓库的区域。相当于一个产品的中转站，在车间完成之后从这里转存到最终的目的地。</li></ol><h3 id="git的常用命令"><a href="#git的常用命令" class="headerlink" title="git的常用命令"></a>git的常用命令</h3><p>我们一般用git bash来完成git的所有工作。因此命令的掌握是非常重要的。</p><ol><li>git clone https://… projectname可以从github中克隆一个仓库</li><li>git status 查看git的三个区域中的文件的状态。</li><li>git status -s 简化版本：例：<br>M README<br>MM Rakefile<br>A lib/git.rb<br>M lib/simplegit.rb<br>?? LICENSE.txt<br>新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左<br>边的 M 表示该文件被修改了并放入了暂存区。Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</li><li>git add相当于文件已经被跟踪并储存到暂存区</li><li>git diff 用来查看尚未暂存的文件更新了哪些部分<br>git diff –cached或者git diff –staged查看已经暂存起来的变化</li><li>git commit将暂存区域中的文件提交到git仓库中<br>可以使用git commit -m ‘将本次的提交信息可以写在这里’<br>git commit -a可以跳过git add（已跟踪文件）</li><li>git rm   连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清 单中了。<br>git rm -f强制删除文件，针对还没有commit的文件</li><li>git mv filename1 filename2可以给文件改名字</li><li>git log 有很多的参数选择</li><li>撤销：有时候提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行<br>$ git commit –amend<br>“git reset HEAD filename撤销将一个文件放入暂存区（移出暂存区）<br>git checkout – filename撤消对文件的修改</li><li>git remote，如果是克隆的会显示origin<br>git remote -v 会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</li></ol><h3 id="关于分支branch"><a href="#关于分支branch" class="headerlink" title="关于分支branch"></a>关于分支branch</h3><p>&emsp;&emsp;首先要区别git fetch 和git pull的区别，这两个的区别显得很重要，要必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。而运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支，一般当前的分支就是master。简单理解：git pull=git fetch+git merge.<br>&emsp;&emsp;关于分支的设计可以说是git显得很强大的一个重要原因，因为篇幅和时间的原因，我准备下次再来好好谈谈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;工欲善其事必先利其器&lt;/code&gt;&lt;br&gt;github被戏称为是世界上最大的同性社交平台，这肯定是有它自己独特的魅力。我也很早就被他的这种魅力所吸引，但是终究只是沉醉于它那富丽堂皇的表面，而迟迟没有去欣赏它真实的内涵。&lt;/p&gt;
&lt;h3 id=&quot;git和githu
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>Blog_01:关于Markdown语法</title>
    <link href="http://www.simbleman.com/2019/08/08/Blog-01-%E5%85%B3%E4%BA%8EMarkdown%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.simbleman.com/2019/08/08/Blog-01-关于Markdown语法/</id>
    <published>2019-08-08T12:00:00.000Z</published>
    <updated>2019-08-08T12:07:54.326Z</updated>
    
    <content type="html"><![CDATA[<pre><code>工欲善其事必先利其器</code></pre><h3 id="1-使用Markdown语法的原因"><a href="#1-使用Markdown语法的原因" class="headerlink" title="1.使用Markdown语法的原因"></a>1.使用Markdown语法的原因</h3><p>&emsp;&emsp;从我开始写blog的第一天就学习了这个Markdown的语法，要说使用它的原因，我现在还真的说不出到底为什么，不过用markdown语法写一段时间文章，相信我你会喜欢上它的。在Markdown设计之初就是致力于是阅读和创作文档变得更容易，在使用的过程中的确有一种效率更高的感觉，因为你再也不需要用鼠标和按钮进行排版了。</p><hr><h3 id="2-Markdown语法"><a href="#2-Markdown语法" class="headerlink" title="2.Markdown语法"></a>2.Markdown语法</h3><p>&emsp;&emsp;最基本的用法在这里我就不具体介绍了，当你在搜索引擎搜索之后会发现教程实在是很多。甚至有教程在宣扬5分钟之内就可以学会，的确学习之后发现Markdown相比于html语法还是比较简单的。但是今天当我重新了解了一遍Markdown之后，我发现有几个语法一直没有注意到,所以就着重记录几个。</p><h4 id="是关于有序列表数字的问题"><a href="#是关于有序列表数字的问题" class="headerlink" title="是关于有序列表数字的问题"></a>是关于有序列表数字的问题</h4><p>&emsp;&emsp;有序列表是通过数字加半角的句号完成的，如”1.”表示第一个。<br>但是在使用的过程中发现数字是可以无序的，也就是说当你1.以后后一行应该用2.但是你用了3.或者任何一个数字显示出来依旧是2.<br>可以看一下接下来的两个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 这是第一行      </span><br><span class="line">6. 这是第二行                     </span><br><span class="line">7. 这是第三行</span><br></pre></td></tr></table></figure></p><p>显示出来：</p><ol><li>这是第一行      </li><li>这是第二行                     </li><li>这是第三行</li></ol><p>所以下次只要注意列表的第一个数字就足够了</p><h4 id="关于转义字符的问题"><a href="#关于转义字符的问题" class="headerlink" title="关于转义字符的问题"></a>关于转义字符的问题</h4><p>&emsp;&emsp;首先说明在Markdown中转义字符是“\”（反斜杠）它可以完成特殊字符的一般化比如\<em>这里的字体没有受到\</em>的影响\*，如果去掉两个转义字符就变成了：<em>这里的字体没有受到\</em>的影响*，显然已经受到了影响（变成粗体了）。</p><h4 id="关于内联元素的链接问题"><a href="#关于内联元素的链接问题" class="headerlink" title="关于内联元素的链接问题"></a>关于内联元素的链接问题</h4><p>&emsp;&emsp;首先看这一段话：“你可以在<a href="https://www.baidu.com/" title="点击百度一下！" target="_blank" rel="noopener">百度</a>上进行搜索，也可以在<a href="https://www.google.com/" title="点击进行谷歌搜索" target="_blank" rel="noopener">谷歌</a>上进行搜索我的blog”<br>以下是上面那句话的源代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“你可以在[百度][]上进行搜索，也可以在[谷歌][]上进行搜索我的blog”</span><br><span class="line"></span><br><span class="line">[百度]: https://www.baidu.com/   &quot;点击百度一下！&quot;</span><br><span class="line">[谷歌]: https://www.google.com/  &quot;点击进行谷歌搜索&quot;</span><br></pre></td></tr></table></figure></p><p>还有第二种实现方法贴上源代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“你可以在[百度][1]上进行搜索，也可以在[谷歌][2]上进行搜索我的blog”</span><br><span class="line"></span><br><span class="line">[1]: https://www.baidu.com/   &quot;点击百度一下！&quot;</span><br><span class="line">[2]: https://www.google.com/  &quot;点击进行谷歌搜索&quot;</span><br></pre></td></tr></table></figure></p><p>以上的效果是一样的但是原理不同，第二种个人感觉有点类似html中的id属性的实现方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;工欲善其事必先利其器
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;1-使用Markdown语法的原因&quot;&gt;&lt;a href=&quot;#1-使用Markdown语法的原因&quot; class=&quot;headerlink&quot; title=&quot;1.使用Markdown语法的原因&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>主题更换以及一些说明</title>
    <link href="http://www.simbleman.com/2019/08/07/%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%8D%A2%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/"/>
    <id>http://www.simbleman.com/2019/08/07/主题更换以及一些说明/</id>
    <published>2019-08-07T11:42:55.000Z</published>
    <updated>2019-08-09T14:36:37.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：主题更换"><a href="#一：主题更换" class="headerlink" title="一：主题更换"></a>一：主题更换</h2><h3 id="1：前情概要"><a href="#1：前情概要" class="headerlink" title="1：前情概要"></a>1：前情概要</h3><p>  &emsp;&emsp;距离我上一次更新已经过去很久了，从上一次更新到现在发生了很多事情，曾一度想关闭这个博客想重新开一个自己的网站，但是想到目前自己真的没有很大的需求去开一个网站，想开网站无非是折腾自己，有点大材小用的意思，所以我还是回到了这个blog。 <br><br>  &emsp;&emsp;4月份和5月份大概是我自己瞎忙的时候，我也不知道自己在忙什么，所以从那个时候开始就想着有时间来整一整，然后才发现真的不要相信自己对自己说的谎话，以后可能是无限期。就这样从六月份开始我应该在忙着准备期末考试了，（嗯..期末就不想提了，太心痛！）那一备考阶段感觉是我上半年最迷茫的时候…所以就这样到7月中旬期末考试结束后我就回家了。接着就是半个月去福建福州和厦门的旅行，可以说是一次身心的放松吧。（虽然被晒得黑了两度！）可以看到页面最上面的背景照片就是我这次在厦门的一个沙滩所拍摄的！在这次更新中我觉得好看就放了上去，接下来谈谈这次的主题更新！</p><h3 id="2-主题更换"><a href="#2-主题更换" class="headerlink" title="2:主题更换"></a>2:主题更换</h3><p> &emsp;&emsp;之前的主题一直用的是next主题，虽然网上的教程很多，但是无论什么样式看来看去真的很丑，所以最近几天就下决心换了一个主题，目前的样式就是所更换之后的主题，是一个中国程序员所编写的BlueLake主题，整个过程他在自己的github主题中写的很详细了，配置也不算太麻烦，感觉比之前的next主题好配置，（也可能我是更熟悉应用了）。所以整个过程没有之前费脑。目前我加上去的最好的功能感觉就是gittalk评论了，但是需要你登录自己的github账号，然后才能评论。我大部分配置的时间是花在了自定义blog的风格上面，这个主题和手机的适配真的也很好，这里就不具体讲这个blog的构造了，可以随处逛逛来自己理解！</p><h3 id="3：日后再要加上的功能"><a href="#3：日后再要加上的功能" class="headerlink" title="3：日后再要加上的功能"></a>3：日后再要加上的功能</h3><p> &emsp;&emsp;目前计划加上的功能有:<br><br> 1:微信支付宝的打赏功能<br><br> 2:被百度搜索引擎收录,并能查询到我的blog(目前已经被谷歌收录)</p><h2 id="二：一些说明"><a href="#二：一些说明" class="headerlink" title="二：一些说明"></a>二：一些说明</h2><h3 id="1：博客给谁看？"><a href="#1：博客给谁看？" class="headerlink" title="1：博客给谁看？"></a>1：博客给谁看？</h3><p>&emsp;&emsp;在我写完这篇blog之前，我几乎没有公开过，甚至于我的舍友看了我的github才知道我写blog。原因首先是因为我的文章数目不够，当别人进来看的时候会不明白我的博客是用来做什么的，其次，我觉得我也没做好准备，目前了解和掌握的“技能点”很少，怕坚持不了第二点说明就自己投降了，<strong>没错重点是第二点说明：</strong></p><h3 id="2：每天写blog！"><a href="#2：每天写blog！" class="headerlink" title="2：每天写blog！"></a>2：每天写blog！</h3><p>&emsp;&emsp;嗯，从今天开始，也就是中国的情人节七夕，以后每天写一篇blog，一直到我写得不想写为止！我将受到所有人的共同监督！<br><br>&emsp;&emsp;<strong>今天的blog算是一个继往开来的第零篇，摆脱过去，重新开始！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一：主题更换&quot;&gt;&lt;a href=&quot;#一：主题更换&quot; class=&quot;headerlink&quot; title=&quot;一：主题更换&quot;&gt;&lt;/a&gt;一：主题更换&lt;/h2&gt;&lt;h3 id=&quot;1：前情概要&quot;&gt;&lt;a href=&quot;#1：前情概要&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="其它" scheme="http://www.simbleman.com/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="DailyBlog" scheme="http://www.simbleman.com/tags/DailyBlog/"/>
    
  </entry>
  
  <entry>
    <title>非常艰难的填坑之路</title>
    <link href="http://www.simbleman.com/2019/03/31/%E9%9D%9E%E5%B8%B8%E8%89%B0%E9%9A%BE%E7%9A%84%E5%A1%AB%E5%9D%91%E4%B9%8B%E8%B7%AF/"/>
    <id>http://www.simbleman.com/2019/03/31/非常艰难的填坑之路/</id>
    <published>2019-03-31T08:28:45.000Z</published>
    <updated>2019-08-07T11:36:48.352Z</updated>
    
    <content type="html"><![CDATA[<p><font size="4"><br>    除了吃饭睡觉，这一天都在填一个其实只要用3行代码解决的坑，这中间伴随着郁闷和无尽的郁闷，甚至到达了怀疑自我的境界。。不过还好就在刚刚成功解决了。现在怀着非常激动的心情来叙说这个艰难的过程的结果。<br></font></p><h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><p>这个坑是有关JSON数据处理的，本来一点不了解这个数据格式的，上次在做微信小程序的时候偶然了解到了它，在做这个数据处理前，我以为会很简单。可是正是因为我的忽视，一开始浪费了很多时间在做无谓的工作。</p><h3 id="关于json的微信小程序处理"><a href="#关于json的微信小程序处理" class="headerlink" title="关于json的微信小程序处理"></a>关于json的微信小程序处理</h3><p>因为要选择一个客户端测试，所以就借用了微信小程序，要在java服务器中处理微信wx.request中的json数据，在微信小程序的js里面一定要<font color="red">先处理</font>,不然等到它把数据发送到服务器端，会发现输出的一直是[object][object]一直看不到具体的对象的值，这时候叫天不应叫地不灵，无论在服务端怎么处理，都会发现是无用功，超级郁闷。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">具体处理方法：</span><br><span class="line">json.stringify()方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串</span><br><span class="line">json.parse() 方法将数据转换为 JavaScript 对象( 将字符串转成json对象。 )</span><br><span class="line"></span><br><span class="line">js中的数据</span><br><span class="line">data: [&#123; &quot;coorx&quot;: 12, &quot;coory&quot;: 13 &#125;,</span><br><span class="line">    &#123; &quot;coorx&quot;: 123, &quot;coory&quot;: 133 &#125;,</span><br><span class="line">    &#123; &quot;coorx&quot;: 123, &quot;coory&quot;: 133 &#125;</span><br><span class="line">    ]</span><br><span class="line">var arrJosn = JSON.stringify(this.data.data);</span><br><span class="line">传输的数据：</span><br><span class="line">data: &#123;</span><br><span class="line">        &quot;data&quot;: arrJosn</span><br><span class="line">      &#125;,</span><br><span class="line">只有这样data传到服务端才能正常显示，真坑啊。</span><br></pre></td></tr></table></figure></p><h3 id="服务端的处理"><a href="#服务端的处理" class="headerlink" title="服务端的处理"></a>服务端的处理</h3><p>在服务端发现是小程序中的json未处理前，在服务端我几乎把所有json处理的方式都试了一遍，但是没有效果。。但是试完了之后发现自己对json这个数据类型处理的思路也很清晰了。<br>我用的是阿里巴巴的fastjson库。<br>不过仔细想想我还是没有明白那个困惑我很久的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    private static final String  JSON_ARRAY_STR = &quot;[&#123;\&quot;coory\&quot;:13,\&quot;coorx\&quot;:12&#125;,&#123;\&quot;coory\&quot;:13,\&quot;coorx\&quot;:12&#125;,&#123;\&quot;coory\&quot;:13,\&quot;coorx\&quot;:12&#125;]&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        JSONArray jsonArray = JSON.parseArray(JSON_ARRAY_STR);</span><br><span class="line">        System.out.println(jsonArray);</span><br><span class="line">&#125;</span><br><span class="line">以上代码运行一点问题都没有</span><br><span class="line">但是如果将JSON_ARRAY_STR变成另一种方法得到的，输出就会一直报错。</span><br><span class="line">    JSONArray jsonArray = new JSONArray();</span><br><span class="line">    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            JSONObject jsonObject = new JSONObject();</span><br><span class="line">            jsonObject.put(&quot;coorx&quot;, 12);</span><br><span class="line">            jsonObject.put(&quot;coory&quot;, 13);</span><br><span class="line">            jsonArray.add(jsonObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String str=jsonArray.toJSONString();</span><br><span class="line">    String JSON_ARRAY_STR=JSON.toJSONString(str);</span><br><span class="line">    JSONArray jsa=JSON.parseArray(JSON_ARRAY_STR);</span><br><span class="line">    执行到最后一句一直报Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: syntax error, expect [, actual string, pos 0, fieldName null</span><br><span class="line">    但是你输出str2跟上面一种方法的JSON_ARRAY_STR一模一样。</span><br><span class="line">    无解啊</span><br></pre></td></tr></table></figure></p><p>最后成功解决的原因就是不用把微信小程序处理过的数据再toJSONString。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String coor=request.getParameter(&quot;data&quot;);</span><br><span class="line">JSONArray jsa=JSONArray.parseArray(coor);</span><br><span class="line">这里直接parseArray于是就成功了转换成了json数组了。</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个坑的主要问题就是上面这些，虽然有些时候很多坑填填是必要的，但是这次的填坑之旅花费了大量的时间，而且非常艰难，这是我对这个问题的简单化造成的，一开始并没有想很系统的去了解和解决这个问题，总是想着网上copy其他人的代码节省时间，现在才发现自己去了解其中的原因和道理才是真正省时间的方法。嗯..还有很多问题等着去解决呢，还是不废话了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;4&quot;&gt;&lt;br&gt;    除了吃饭睡觉，这一天都在填一个其实只要用3行代码解决的坑，这中间伴随着郁闷和无尽的郁闷，甚至到达了怀疑自我的境界。。不过还好就在刚刚成功解决了。现在怀着非常激动的心情来叙说这个艰难的过程的结果。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="微信小程序" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="json" scheme="http://www.simbleman.com/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>队列的实现</title>
    <link href="http://www.simbleman.com/2019/03/26/%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.simbleman.com/2019/03/26/队列的实现/</id>
    <published>2019-03-26T05:47:43.000Z</published>
    <updated>2019-08-07T11:36:17.060Z</updated>
    
    <content type="html"><![CDATA[<font size="4"><br>    队列也是一种特殊的线性表，它的特点是先进先出，所有的插入操作都在表的一端进行，而删除操作都在表的另一端进行，<br></font><h2 id="队列的指针实现"><a href="#队列的指针实现" class="headerlink" title="队列的指针实现"></a>队列的指针实现</h2><p>因为队列要在线性表的两段进行操作，为了方便使用，就不能像栈那样只有个节点型就好了，因此它的定义和栈会有不同。</p><h3 id="队列的定义和初始化"><a href="#队列的定义和初始化" class="headerlink" title="队列的定义和初始化"></a>队列的定义和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">队列的节点定义</span><br><span class="line">struct node&#123;</span><br><span class="line">    node *next;</span><br><span class="line">    int element;</span><br><span class="line">&#125;;</span><br><span class="line">队列的定义</span><br><span class="line">struct QUEUE&#123;</span><br><span class="line">    node * front;//表头节点</span><br><span class="line">    node * rear;//指向最后一个元素的节点</span><br><span class="line">&#125;;</span><br><span class="line">初始化</span><br><span class="line">void init(QUEUE &amp;q)&#123;//初始化为空表，头指针和尾指针重合 </span><br><span class="line">    q.front=new node;</span><br><span class="line">    q.front-&gt;next=NULL;</span><br><span class="line">    q.rear=q.front;</span><br><span class="line">    cout&lt;&lt;&quot;初始化成功&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作（在队列的尾部进行）"><a href="#插入操作（在队列的尾部进行）" class="headerlink" title="插入操作（在队列的尾部进行）"></a>插入操作（在队列的尾部进行）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void enqueue(int x,QUEUE &amp;q)&#123;</span><br><span class="line">    q.rear-&gt;next=new node;</span><br><span class="line">    q.rear=q.rear-&gt;next;</span><br><span class="line">    q.rear-&gt;next=NULL;</span><br><span class="line">    q.rear-&gt;element=x;</span><br><span class="line">    cout&lt;&lt;&quot;插入队列成功&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作（在队列的头部进行）"><a href="#删除操作（在队列的头部进行）" class="headerlink" title="删除操作（在队列的头部进行）"></a>删除操作（在队列的头部进行）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void dequeue(QUEUE &amp;q)&#123;</span><br><span class="line">    node * temp;</span><br><span class="line">    if(q.rear==q.front)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该队列为空！&quot;&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        temp=q.front-&gt;next;</span><br><span class="line">        q.front-&gt;next=temp-&gt;next;</span><br><span class="line">        delete temp; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列的数组实现（循环数组）"><a href="#队列的数组实现（循环数组）" class="headerlink" title="队列的数组实现（循环数组）"></a>队列的数组实现（循环数组）</h2><p>因为队列的特殊性，一般的数组难以满足完美地满足它的要求，所以这里用循环数组来实现它。</p><h3 id="队列的定义和初始化-1"><a href="#队列的定义和初始化-1" class="headerlink" title="队列的定义和初始化"></a>队列的定义和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">    int elements[maxlength];</span><br><span class="line">&#125;QUEUE; </span><br><span class="line"></span><br><span class="line">void init(QUEUE &amp;Q)&#123;//将队列置为空 </span><br><span class="line">    Q.front=0;</span><br><span class="line">    Q.rear=maxlength-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：为了防止循环队列队满和队空的状态相同，因此这里将rear比front滞后一个位置做为队空的状态，front为0，rear为maxlength-1，而把rear所指单元比front滞后两个位置做为队满的状态。</p><h3 id="循环数组很重要的addone函数"><a href="#循环数组很重要的addone函数" class="headerlink" title="循环数组很重要的addone函数"></a>循环数组很重要的addone函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addone函数算是实现了循环数组循环的条件</span><br><span class="line">int addone(int i)&#123;</span><br><span class="line">    return ((i+1)%maxlength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入操作（将rear往前移动一个位置（顺时针））"><a href="#插入操作（将rear往前移动一个位置（顺时针））" class="headerlink" title="插入操作（将rear往前移动一个位置（顺时针））"></a>插入操作（将rear往前移动一个位置（顺时针））</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void insert(QUEUE &amp;Q,int x)&#123;</span><br><span class="line">    if(addone(addone(Q.rear))==Q.front)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该队列已满！&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Q.rear=addone(Q.rear);</span><br><span class="line">        Q.elements[Q.rear]=x;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;&quot;插入队列成功！&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作-将front往前移动一个位置（顺时针）"><a href="#删除操作-将front往前移动一个位置（顺时针）" class="headerlink" title="删除操作(将front往前移动一个位置（顺时针）)"></a>删除操作(将front往前移动一个位置（顺时针）)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void deleteq(QUEUE &amp;q)&#123;</span><br><span class="line">    if(addone(q.rear)==q.front)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该附列已空&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        q.front=addone(q.front);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font size=&quot;4&quot;&gt;&lt;br&gt;    队列也是一种特殊的线性表，它的特点是先进先出，所有的插入操作都在表的一端进行，而删除操作都在表的另一端进行，&lt;br&gt;&lt;/font&gt;

&lt;h2 id=&quot;队列的指针实现&quot;&gt;&lt;a href=&quot;#队列的指针实现&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.simbleman.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://www.simbleman.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈的实现</title>
    <link href="http://www.simbleman.com/2019/03/25/%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.simbleman.com/2019/03/25/栈的实现/</id>
    <published>2019-03-25T13:31:20.000Z</published>
    <updated>2019-08-07T11:31:24.114Z</updated>
    
    <content type="html"><![CDATA[<p><font size="4"><br>    栈和队列都是一种特殊的线性表，因此都可以用指针和数组来实现它。在这里只实现他的一些关键的操作函数和方法。<br></font></p><h2 id="栈的数组实现"><a href="#栈的数组实现" class="headerlink" title="栈的数组实现"></a>栈的数组实现</h2><p>栈的数据逻辑特点是先进后出，所以一般用数组的最后位置当做栈的底部，而把数组开头的元素当做栈的顶部，因此入栈也称作压栈，且数据的删除和插入操作都只在栈的一端进行，因此栈的数据结构有int型的top，指向栈顶元素，还有一个数组用于存放栈的元素。</p><h3 id="1：栈的数组结构体定义和初始化"><a href="#1：栈的数组结构体定义和初始化" class="headerlink" title="1：栈的数组结构体定义和初始化"></a>1：栈的数组结构体定义和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const int maxsize=100;</span><br><span class="line">struct STACK&#123;</span><br><span class="line">    int top;</span><br><span class="line">    int elements[maxsize];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void init(STACK &amp;s)&#123;</span><br><span class="line">    s.top=maxsize;//当top为maxsize时，则栈为空 </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-push操作"><a href="#2-push操作" class="headerlink" title="2:push操作"></a>2:push操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void push(STACK &amp;s,int x)&#123;</span><br><span class="line">    if(s.top==0)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该栈已满&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        s.top-=1;</span><br><span class="line">        s.elements[s.top]=x;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;&quot;压栈成功&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-pop操作"><a href="#3-pop操作" class="headerlink" title="3:pop操作"></a>3:pop操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void pop(STACK &amp;s)&#123;</span><br><span class="line">    if(s.top==maxsize)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该栈为空&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        s.top+=1;</span><br><span class="line">        cout&lt;&lt;&quot;出栈成功，已删除栈顶元素&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：其他操作功能可以根据需要进行设计</p><h2 id="栈的指针实现"><a href="#栈的指针实现" class="headerlink" title="栈的指针实现"></a>栈的指针实现</h2><p>栈的指针实现同数组实现，他的数据的插入和删除操作都在表头进行，和数组实现相比没有栈满的情况出现。</p><h3 id="1-结构体定义及初始化"><a href="#1-结构体定义及初始化" class="headerlink" title="1:结构体定义及初始化"></a>1:结构体定义及初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">    node * next;</span><br><span class="line">    int element;</span><br><span class="line">&#125;;</span><br><span class="line">typedef node * STACK;</span><br><span class="line"></span><br><span class="line">void init(STACK &amp;S)&#123;//初始化即将栈置空</span><br><span class="line">    S=new node;</span><br><span class="line">    S-&gt;next=NULL;</span><br><span class="line">    cout&lt;&lt;&quot;初始化成功！&quot;&lt;&lt;endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-push操作-1"><a href="#2-push操作-1" class="headerlink" title="2:push操作"></a>2:push操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void push(STACK &amp;s,int x)&#123;</span><br><span class="line">    STACK stk;</span><br><span class="line">    stk=new node;</span><br><span class="line">    stk-&gt;element=x;</span><br><span class="line">    stk-&gt;next=s-&gt;next;</span><br><span class="line">    s-&gt;next=stk;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;&quot;入栈成功&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-pop操作-1"><a href="#3-pop操作-1" class="headerlink" title="3:pop操作"></a>3:pop操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void pop(STACK &amp;s)&#123;</span><br><span class="line">    STACK stk;</span><br><span class="line">    cout&lt;&lt;s-&gt;next-&gt;element&lt;&lt;&quot;出栈成功！&quot;&lt;&lt;endl; </span><br><span class="line">    if(s-&gt;next!=NULL)&#123;</span><br><span class="line">        stk=s-&gt;next;</span><br><span class="line">        s-&gt;next=stk-&gt;next;</span><br><span class="line">        delete stk;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        cout&lt;&lt;&quot;错误，该栈为空&quot;&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font size=&quot;4&quot;&gt;&lt;br&gt;    栈和队列都是一种特殊的线性表，因此都可以用指针和数组来实现它。在这里只实现他的一些关键的操作函数和方法。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;栈的数组实现&quot;&gt;&lt;a href=&quot;#栈的数组实现&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="学习" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据结构" scheme="http://www.simbleman.com/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://www.simbleman.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="http://www.simbleman.com/tags/%E6%A0%88/"/>
    
  </entry>
  
</feed>
